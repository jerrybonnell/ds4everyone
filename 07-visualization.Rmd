# Visualization 

Tables are a powerful way of organizing and visualizing data. However, large tables of numbers can be difficult to interpret, no matter how organized they are. Sometimes it is much easier to interpret graphs than numbers.

## Scatter plots and Line graphs

In this chapter we will develop some of the fundamental graphical methods of data analysis. Our source of data is the `mpg` dataset, which contains observations collected by the US Environmental Protection Agency on 38 models of car between 1999 and 2008. We visited this dataset briefly in Section \@ref(introtables), but we turn to it again to reveal interesting properties about it, made possible by visualization. 

R provides many facilities for creating visualizations, but `ggplot2` provides one of the most elegant and flexible ways of doing so. Moreover, `ggplot2` is based on a system called the *grammar of graphics*, and learning it will allow you to apply the tool to many visualization tasks. 

### Prerequisites

This chapter will make great use of `ggplot2`, which is also a component of the tidyverse. Loading in the tidyverse will also load in `ggplot2`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### The `mpg` data frame  

The table has 234 rows and 11 columns. Use `?mpg` open its help page. Let's have a look at a snapshot of the data again.  

```{r}
mpg
```

Another way to preview the data is by using `glimpse()`. 

```{r}
glimpse(mpg)
```

__Terminology.__ A *variable* is a formal name for what we have been calling a "feature", such as "highway miles per gallon." The term variable emphasizes that the feature can have different values for different individuals – the numbers of movies that actors have been in varies across all the actors.

Variables that have numerical values, such as 'highway miles per gallon' or 'engine displacement' are called *quantitative* or *numerical* variables.

### The layered grammar of graphics

The grammar of graphics states that every plot can be built from the same few components: (1) a __dataset__, (2) a set of __geoms__, and (3) a __coordinate system__. These are built in *layers*. 

A plot is built using the `ggplot()` function. This creates a default coordinate system where layers can be added on. The first argument is the dataset to use in the graph. For example, `ggplot(data = mpg)` tells `ggplot2` to set up an empty graph where the `mpg` dataset will be the data used for plotting. 

The layers we add are geometrical objects called __geoms__. We have a natural intuition for the type of geom a plot uses, e.g., bar charts use *bar* geoms and line charts use *line* geoms. Scatter plots, however, use *point* geoms. There are many more geoms available; the `ggplot2` [cheatsheet provides a nice overview](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf). 

To display data values, variables in the dataset are mapped to *aesthetic*, or visual, properties of the geom, such as shape, size, and x and y locations. So each geom function will take an argument called `mapping` paired with a function call to `aes()` to specify the mapping from variable to aesthetic. `ggplot2` will look for the mapped variables inside the data argument; in this case, `mpg`. Let's see how these components come together in a scatter plot.    

### Scatter Plots 

A *scatter plot* displays the relation between two numerical variables. You saw an example of a scatter plot in an early section where we looked at the number of periods and number of characters in two classic novels. We will use a scatter plot here to visualize the relationship between a car's fuel efficiency (`hwy`) and the number of engines it has (`displ`).

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

Here, a point geom is used where the variables `displ` and `hwy` from `mpg` are mapped to the aesthetics `x` and `y`. Each point corresponds to one car model in the dataset. You can see that it slopes downward, in general. The more engines a car has, the less fuel efficient it is -- in general. 

Formally, we say that the plot shows an *association* between the variables, and that the association is *negative*: high values of one variable tend to be associated with low values of the other, and low values of one with high values of the other, in general. Later in the course we will study how to quantify association. For the moment, we will just think about it qualitatively.

Of course there is some variability. For instance, observe the group of car models that have a large numbers of engines, yet are still fuel efficient. We are suspect that these points are *outliers* because they lie outside the general range of the data. 

How can we explain these points? One way is to introduce a new variable `class` to visualize how the "type" of car impacts its fuel efficiency. The plot above can be amended to include a color aesthetic, where the type of car is mapped to a color. 

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

This visualization makes one thing very clear: the outliers are sports cars! Even though sports cars have larger engines, they are more efficient than other cars with more engines because of their smaller body form, compared to SUVs.

__Other types of aesthetics.__ It is possible to include other types of aesthetics other than the color used in the above plot. For instance, the class can be mapped to `shape` or `alpha` aesthetics. 

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

### Positional Adjustments

The careful reader will observe that there are 234 entries in the dataset. However, much less (only 109 to be exact) appears in the scatterplot. The issue is that the points are rounded so the points appear on a grid and many points overlap each other. This problem is known as __overplotting__. This makes it hard to see where the mass of the data is. 

The gridding can be avoided by setting the position adjustment to “jitter” in the geom.  `position = "jitter"` adds a small amount of random noise to each point. This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

### Line Graphs

Line graphs are among the most common visualizations and are often used to study chronological trends and patterns. For instance, we can use a line graph to study `airmiles`, which contains data about passenger miles on commercial US airlines between 1937 and 1960. 

```{r, echo = FALSE}
df_airmiles <- data.frame(
  miles = as.matrix(airmiles), date = time(airmiles))
```

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = df_airmiles) + 
  geom_line(mapping = aes(x = date, y = miles))
ggplot(data = df_airmiles) + 
  geom_smooth(mapping = aes(x = date, y = miles))
```

The line geom creates the familiar line graph we typically think of while the smooth geom "smooths" the line to aid the eye in seeing overall patterns; the line geom, in contrast, is much more "ridgy". The smooth geom also adds confidence bands on the smoother.

The smooth geom can be useful to confirm the negative trend observed in the `mpg` data frame. 

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

Here we have layered *two* geoms in the same graph: a point geom and a smooth geom. Note how the outlier points have influenced the overall shape of the curve to bend upward, muddying the claim that there is a strong negative trend present in the data. Armed with our understanding about sports cars, we can adjust the visualization by setting aside points with `class == "2seater"`.         

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

This plots shows a much more graceful trend downward. Before moving on, we point out some redundancy present in our plotting code. Namely, we have defined the same mapping for `x` and `y` in two different places. This could cause some unexpected surprises when writing code: imagine if we wanted to change the y-axis to `cty` instead of `hwy`, but we forgot to change both occurrences of `hwy`. This can be amended by moving the mapping to `ggplot()`.     

```{r, eval = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth()
```

We can extend this idea further to specify different `data` for each layer. Here, the smooth geom displays only a subset of the data, the sports cars.  

```{r, eval = FALSE, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

We can also write this more concisely by omitting some keywords:

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point(aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

In the rewritings we have taken here, the same effect is obtained. 

## Visualizing Categorical Distributions 

Data come in many forms that are not numerical. Data can be pieces of music, or places on a map. They can also be categories into which you can place individuals. Here are some examples of *categorical* variables.

* The individuals are pies sold, and the variable is the type of pie.
* The individuals are diamonds, and the variable is the quality of the cut.
* The individuals are car manufacturers, and the variable is the class of the car, e.g., "compact", "SUV",  and "pickup."
* The individuals are survey respondents, and the variable is the response they choose from among "Not at all satisfied," "Somewhat satisfied," and "Very satisfied."

### Prerequisites

This section will continue to make use of `ggplot2`, so we will need the tidyverse. Moreover, we will make use of datasets that are not available in the tidyverse, but are available in the package `faraway`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(faraway)
```

### The `happy` and `diamonds` data frames

The table `happy` contains data on 39 students in a Univeristy of Chicago MBA class. 

```{r}
happy
```

Armed with what we have learned about `ggplot2`, we can begin answering questions about this dataset using table manipulation and visualization techniques. For instance, which "happiness" scores are the most frequent among the students? Moreover, can an association be determined between feelings of belongingness and higher scores of happiness? How about family income?  

Before we inspect this dataset any further, we will also consider another table called `diamonds`, which contains data on almost 54,000 diamonds.   

```{r}
diamonds
```

The *values* of the categorical variable *cut* are "fair", "good", "very good", "ideal", and "premium". We can look at how many diamonds are in each category. 

```{r, message = FALSE}
diamonds %>%
  group_by(cut) %>%
  summarise(count = n())
```

The table shows the number of diamonds of each cut. We call this a *distribution table*. A distribution shows all the values of a variable, along with the frequency of each one.

### Bar Chart

The bar chart is a familiar way of visualizing categorical distributions. It displays a bar for each category. The bars are equally spaced and equally wide. The length of each bar is proportional to the frequency of the corresponding category.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = diamonds, mapping = aes(x = cut)) + 
  geom_bar()
```

The y-axis displays *cut*, a variable from `diamonds`. However, the x-axis displays *count*, a variable not from `diamonds`. How is this possible? 

Line geoms and point geoms simply plot the raw values given from the dataset. Bar geoms, however, calculate *new* values to plot, like a *count*. The algorithm used to compute the new values is called a statistical transformation, or __stat__. It works as follows.

```{r, echo=FALSE, fig.align="center", fig.asp=1/2, fig.cap="Figure courtesy of *R for Data Science*, Grolemund and Wickham"}
knitr::include_graphics('images/visualization-stat-bar.png')
```

To summarize: `ggplot2` transforms the raw table to a new dataset of categories with its corresponding counts. From this new table, the bar plot is constructed by mapping `cut` to the x-axis and `count` to the y-axis. 

The default stat used is `stat_count()`, which counts the number of cases at each `x` position. If the counts are already present in the dataset and we would prefer to instead use these directly  for the heights of the bars, we can set `stat = "identity"`. For instance, consider this table about popular pies sold at a bakery. The "count" is already present in the `sold` variable. 

```{r, fig.align="center", dpi=80, warning = FALSE}
store_pies <- tribble(
  ~pie,             ~sold,
  "Pecan",            906,
  "Key Lime",         620,
  "Pumpkin",          202,
  "Apple",            408,
  "Mississippi mud",  551
)
ggplot(data = store_pies) +
  geom_bar(mapping = aes(x = pie, y = sold), stat = "identity")
```

Note how both `x` and `y` aesthetics must be provided when using the `identity` stat. 

### Towards numerical variables 

Let's turn to the `happy` data frame. We can consider the *categories* to be points on the 10-point scale, and the *individuals* the students in each interval. Let's determine this distribution table. 

```{r out.width = "50%", fig.align="default", message = FALSE}
happy_students <- group_by(happy, happy) %>% 
  summarise(count = n())
happy_students
```
We can now use this table, along with the graphing skills that we acquired above, to draw a bar chart that shows which scores are most frequent among the 39 students.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = reorder(happy, -count), y = count), stat = "identity") +
  xlab("Happy score")
```

There is something unsettling about this chart. Though it does answer the question of which "happy" scores appear most frequently among the students, it doesn't list the scores in chronological order. It is treating `happy` as a categorical variable.

But the scores are fixed chronological units that do have an order. Let's see what happens when we try to take that into account. In the `ggplot2` code written above, `reorder()` was used to sort the categories (scores) from highest to lowest. Let's run the code again without sorting by count.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = happy, y = count), stat = "identity") +
  xlab("Happy score")
```

Now the scores are in increasing order. We can attempt an answer to our second question: is there an association between feelings of belonginess and "happy" scores? Put another way, what relationship, if any, exists between `love` and `happy`? 

### More on positional adjustments

With point geoms we saw the usefulness of the "jitter" position adjustment to overcome the problem of overplotting. Bar geoms similarly benefit from positional adjustments. For instance, we can set the `color` or `fill` of a bar plot.

```{r eval = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

To make this code work, note how the parameter passed to the `color` and `fill` aesthetic is converted to a factor, or categorical variable, via `as.factor()`. As discussed, the `happy` variable is *numerical*. However, `ggplot2` can only color or fill a bar chart based on a categorical variable.    

Something interesting happens when the fill aesthetic is mapped to another variable other than `happy`, e.g., `love`.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)))
```

This visualization produces a "stacked" bar chart! Each bar is a composite of both `happy` and `love`. It also reveals something else that is interesting: feelings of belonginess are associated with higher marks on the "happy" scale. While we must maintain caution about making any causative statements at this point, this visualization demonstrates that bar charts can be a useful aid when exploring a dataset for possible relationships.

The stacking is performed by the position adjustment specified by the `position` argument. Observe how the bar chart changes with these other options: 

* `position = "fill"` makes each bar the same height. This way we can compare proportions across groups. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "fill")
```

* `position = "dodge"` places the stacked bars directly *beside* one another. This makes it easier to compare individual values. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "dodge")
```

Bar charts are intended as visualizations of categorical variables. When the variable is numerical, the numerical relations between its values have to be taken into account when we create visualizations. That is the topic of the next section. Before ending the discussion here, we turn to one more important piece of `ggplot2` magic.  

### Coordinate Systems 

We noted earlier that one of the three motifs of any `ggplot2` plot is its coordinate system. In all of the `ggplot2` code we have seen so far, there has been no explicit mention as to the coordinate system to use. Why? If no coordinate system is specified, `ggplot2` will default to using the Cartesian coordinate system. In Cartesian coordinates, the `x` and `y` coordinates are used to define the location of every point in the dataset, as we have just seen. 

This is not the only coordinate system offered by `ggplot2`, and learning about other coordinate systems that are available can help boost the overall quality of a visualization.

* `coord_flip()` flips the `x` and `y` axes. For instance, this can be useful when the x-axis labels on a bar chart overlap each other.  

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip()
```


* `coord_polar()` uses polar coordinates. It is useful for plotting a Coxcomb chart. Note the connection between this and a bar chart.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_polar()
```

* `coord_cartesian(xlim, ylim)` can be passed arguments for "zooming in" the plot. For instance, we may want to limit the height of very tall bars (and, similarly, the effect of very small bars) in a bar chart by passing in a range of possible y-values to `ylim`.   

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip() +
  coord_cartesian(ylim=c(1,10))
```

This can also be a neat trick for eliminating the (awkward) gap between the bars and the x-axis :-)

## Visualizing Numerical Distributions 

hi


