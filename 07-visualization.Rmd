---
output:
  html_document: default
  pdf_document: default
---

# Data Visualization

As you develop familiarity with processing data, you learn how to develop intuition from the data at hand by glancing at its values. Unfortunately, there is only so much you can do with glancing at values. There is a substantial limitation to what you can obtain when the data at hand is so large.

Visualization is a powerful tool in such cases. In this chapter we introduce another key member of the tidyverse, the `ggplot2` package, for visualization.

## Introduction to `ggplot2`

R provides many facilities for creating visualizations. The most sophisticated of them, and perhaps the most elegant, is `ggplot2`. In this section we introduce generating visualizations using `ggplot2`.   

### Prerequisites

We will make use of the tidyverse in this chapter, so letâ€™s load it in as usual.

```{r message = FALSE, warning = FALSE}
library(tidyverse)
```

### The layered grammar of graphics 

The structure of visualization with `ggplot2` is by way of something called the  *layered grammar of graphics* -- a name that will certainly impress your friends! 

The name of the package `ggplot2` is a bit of a misnomer as the main function we call to visualize the data is `ggplot`. As with `dplyr` and `stringr`, the `ggplot2` [cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) is quite helpful for quick referencing.

Each visualization with `ggplot` consists of some building blocks. We call these *layers*. There are three types of layers:

* the __base layer__, which consists of the background and the coordinate system,
* the __geom layers__, which consist of individual geoms, and
* the __ornament layers__, which consists of titles, legends, labels, etc.

We call the plot layers `geom` layers because each plot layer requires a call to a function with the name starting with `geom_`. There are many geoms available in `ggplot` and you can think of these as the buildings blocks that compose many of the diagrams you are already familiar with. For instance, *point* geoms are used to create scatter plots, *line* geoms for line graphs, *bar* geoms for bar charts, and *histogram* geoms for histograms -- check out the cheat sheet for many more! We will explore the main geoms in this chapter. 

To specify the base layer, we use the function `ggplot()`. Using the function alone is rather unimpressive.  

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot()
```

All `ggplot2` has done so far is set up a blank canvas. To make this plot more interesting, we need to specify a dataset and a coordinate system to use. To build up the discussion, let us turn to our first geom: the *point* geom.  

## Point geoms

Let us begin our exploration with the *point* geom. As noted earlier, point geoms are useful in that they can be used to construct a *scatter plot*. 

### Prerequisites

We will make use of the tidyverse in this chapter, so let us load it in as usual.

```{r message = FALSE, warning = FALSE}
library(tidyverse)
```

### The `mpg` tibble 

We will use the `mpg` dataset as our source for this section. This dataset is collected by the US Environmental Protection Agency and shows information about 38 models of car between 1999 and 2008. We have visited this data in earlier sections. Use `?mpg` to open its help page for more information.

The table `mpg` has 234 rows and 11 columns. Use  Let us have a look at a snapshot of the data again.  

```{r}
mpg
```

Another way to preview the data is using `glimpse`. 

```{r eval=FALSE}
glimpse(mpg)
```

### Your first visualization

We first specify the base layer. Unlike before, this time we specify our intention to use the `mpg` dataset.  

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = mpg)
```

We are still presented with a profoundly useless plot. Let us amend our code a bit. 

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

Ta-da, our first visualization! Let us unpack what we just did. 

The first line of this code specifies the *base layer* with the argument `data = ` and the second line describes the *geom layer* where a point geom is to be used along with a mapping known as an *aesthetic*. More specifically, we designate the point geom by calling the function `geom_point` and a *coordinate system* by passing to the function an argument containing the *aesthetic* (the value that follows `mapping = `).

An aesthetic *maps* information from a data frame or tibble to characteristics of a plot. A plot will often use [Cartesian coordinates](https://en.wikipedia.org/wiki/Cartesian_coordinate_system) where each axis represents an attribute of the data frame and we map variables on to the x and y axes, respectively. In the case of this plot, we map `displ` to the x-axis and `hwy` to the y-axis. 

To round up the discussion, here are the key points from the code we have just written: 
* There is one `ggplot` and one `geom_point`.
* The `ggplot` call preceded the `geom_point` call.
* The plus sign `+` connects the two calls.
* A `data` specification appears in the `ggplot` call.
* A `mapping` specification appears in the `geom_point` call.

The semantics of the code is as follows:

* Instruct `ggplot` to get ready for creating plots using `mpg` as the data.
* Instruct `geom_point` to create a plot using `displ` as the x-axis and `hwy` as the y-axis, where the two variables are from the data frame `mpg`.

### Scatter plots 

Our first visualization is an example of a scatter plot. A *scatter plot* is a plot that presents the relation between two numerical variables.

In other words, a scatter plot of variables `A` and `B` draws data from a collection of pairs `(a,b)`, where each pair comes from a single observation in the data set.
The number of pairs you plot can be one or more. There is no restriction on the frequencies we observe the same pair, the same `a`, and the same `b`.

We can use a scatter plot here to visualize the relationship between the highway fuel efficiency (`hwy`) and the displacement of its engine (`displ`).

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

Each point on the plot is the pair of values of one car model in the dataset.
Note that there are quite a few groups of points that align horizontally and quite a few groups of points that align vertically. The former are groups that share the same (close to the same) `hwy` values with each other, the latter are groups that share the same (close to the same) `displ` values with each other. We can observe a graceful trend downward in the plot -- lower engine displacement is associated with more highway miles per gallon.   

<!-- Also, we can omit the prefix `data = ` and `mapping =`.
The example below again does the same.

```{r, eval = FALSE, fig.align="center", dpi=80}
ggplot(mpg) +
  geom_point(aes(x = displ, y = hwy))
``` 
--> 

### Adding color to your geoms

It appears that the points are following some downward trend. Let us examine this more closely by using `ggplot` to assign colors to its points.

You can specify the attribute for `ggplot` to use to determine the colors, for instance, the `class` attribute. We make the specification in the `aes` of `geom_point`.

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

This visualization allows us to make new observations about the data. Namely, it appears that there is a cluster of points from the "2seater" class that veer off to the right and seem to break the overall trend present in the data. Let us set aside these points to compose a new dataset.  

```{r dpi=80,  fig.align="center", warning = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

After the removal of the "2seater" class, the downward trend appears more vivid.

### Categorical variables 

Coloring points according to some attribute is useful when dealing with *categorical variables*, that is, variables whose values come from a fixed set of categories. For instance, a variable named `ice_cream_flavor` may have values that are from the categories *chocolate*, *vanilla*, or *strawberry*; in terms of the `mpg` data, `class` can have values that are from the categories *compact*, *midsize*, *pickup*, *subcompact*, or *suv*.   

Can we develop more insights from categorical variables?

Using the `mutate` function, we can create a new categorical variable `japanese_make`, which is either `TRUE` or `FALSE` depending on whether the manufacturer is one of Honda, Nissan, Subaru, or Toyota. We create a new dataset with the addition of this new variable. 

```{r}
no_sports_cars <- no_sports_cars %>% 
  mutate(japanese_make = 
           manufacturer %in% c("honda", "nissan", "subaru", "toyota"))
```


Let us create a new plot using `japanese_make` as a coloring strategy. 

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = japanese_make))
```

We can observe a downward trend in the data for cars with a Japanese manufacturer.

Let us try a second categorical variable: `cyl`.

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cyl))
```

This one has a striking difference compared to our other visualizations. Can you spot the difference? Try to pick it out before reading on. 

The legend appearing to the right of the dots looks very different. Instead of dots showing the color specification, it uses a bar with a blue gradient. The reason is that `ggplot` treats the `cyl` attribute as a *continuous variable* and needs to be able to select colors for values that are, say, *between* 4 and 5 cylinders or 7 and 8 cylinders. The appropriate way to do this is by means of a gradient.   

This comes as a surprise to us -- there is no such thing as 4 and three quarters of a cylinder because `cyl` is a categorical variable. The only possible values are either 4, 5, 6, 7, or 8, and nothing in between. How to inform `ggplot` of this fact? 

The solution is to treat `cyl` as a *factor*, which is synonymous with saying that a variable is categorical. The function to use is called `as.factor()`. Let us amend our original attempt to include the call. 

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = as.factor(cyl)))
```

This one bears a resemblance that we are already familiar with. 

Run your eyes from left to right along the horizontal axis. Observe how for a given `hwy` value, say points around `hwy = 20`, there is a clear transition from cars with 4 cylinders (in red) to cars with 6 cylinders (in cyan) and finally to cars with 8 cylinders (in purple). In contrast, if we look at points at, say around `disp = 2`, and run our eyes along the vertical axis, we do not observe such a transition in color -- all the points still correspond to cars with 4 cylinders (in red).  

This tells us that there is a stronger association between the continuous variable `displ` and the categorical variable `cyl` than between `hwy` and `cyl`.   

Here is one more plot. Let us plot `hwy` against `cty` when coloring according to `cyl`. We naturally assume that the higher a car model's highway miles per gallon is (`hwy`), the higher its city miles per gallon (`cty`) is as well, and vice versa.

```{r}
ggplot(no_sports_cars) + 
  geom_point(aes(x = cty, y = hwy, color = as.factor(cyl)))
```

This one reveals a *positive association* in the data, as opposed to the *negative association* that we observed in the downward trend in the plot of `hwy` against `displ`. We can also see a greater transition in color as we move left to right in the plot, suggesting a stronger relationship between `cty`and `cyl`. 

Observe that there are two points that seem to be very far off to the right and one point off to the left. We may call such data points *outliers* meaning that they do not appear to conform to the associations that other observations are following. Let us isolate these points using `filter`. 

```{r}
no_sports_cars %>% filter(cty < 10 | cty > 32.5) %>% 
  relocate(cty, .after = year) %>%
  relocate(hwy, .before = cyl)
```

We see that the four Dodges and one Jeep are the far left points and two Volkswagens are the far right points.

### Continuous variables 

Given what we learned when experimenting with `cyl`, we might be curious as to what can be gleaned when we intend on coloring points according to a *continuous variable*. Let us try it with the attribute `cty`, which represents the city fuel efficiency.

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cty))
```

The blue gradient makes it hard to see changes in the color. Can we use a different gradient other than blue?

Yes! The solution is to add a layer `scale_color_gradient` at the end with two colors names of our choice. In the style of art deco, we pick two colors, `yellow3` and `blue`.

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cty)) +
  scale_color_gradient(low = "yellow3", high="blue")
```

Contrast this plot with the one we saw just before with `hwy` versus `displ` when coloring according to `cyl`. The situation is reversed here: as we run our eye up and down for some value of `displ`, we see a transition in color; the same is not true when moving along horizontally. Thus, it seems that `cty` is associated more with `hwy` than `displ`. 

By the way, where do we get those color names? There's a [cheatsheet](https://www.nceas.ucsb.edu/sites/default/files/2020-04/colorPaletteCheatsheet.pdf) for that! 

### Use Articulations Other Than Colors

#### Facets

Instead of using color to annotate points, we can also use something called *facets* which splits the plots into several subplots, one for each category of the categorical variable. Let us use faceting for our last visualization.   

```{r dpi=80,  fig.align="center", warning = FALSE}
ggplot(data = no_sports_cars) +
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ as.factor(cyl), nrow = 2)
```

This one makes it very clear that hardly any car models in the dataset have 5 cylinders! 

#### Shapes

You can use shapes and fill strengths to differentiate between points. The argument for the fill strength is `alpha = X` where `X` is the attribute.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(no_sports_cars) + 
  geom_point(aes(x = cty, y = hwy, alpha = class))
```

You can specify both `alpha` and `color`, even using different variables. See an example below.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(no_sports_cars) + 
  geom_point(aes(x = cty, y = hwy, alpha = displ, shape = class))
```

Welcome to your first 4-D visualization! Note how when we move up and down vertically for some fixed value of `cty`, the shapes do not grow more transparent; this is only observed as we move left and right at some fixed value of `hwy`, suggesting a stronger relationship between `cty` and `displ`. Put another way, we can say that `displ` varies more with `cty` than it does with `hwy`. We do not observe a strong effect with respect to the shapes in `class`. 

Note that by mapping both the `shape` and `color` aesthetics to the same attribute, say, `class`, the legends are collapsed into one.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(no_sports_cars) + 
  geom_point(aes(x = cty, y = hwy, shape = class, color = class))
```

Can you say whether this visualization contains more or less information than our last one? How many dimensions are displayed here?  

### Jittering

You may notice that despite the fact that there are 234 entries in the data set, much fewer points (only 109 to be exact) appears in the initial (before filtering) scatter plot of `mpg`.

This is because many points collide on the plot. We call the phenomenon __overplotting__, meaning one point appearing over another. It is possible to nudge points in a random direction in a small quantity. By making all directions possible, we can make complete overplotting a rare event. We call the random nudging arrangement *jittering*.

To jitter, we add a positional argument `position = "jitter"` to `geom_point`. Note that this is not a part of the aesthetic specification (so is not inside `aes`).

```{r, fig.align="center", dpi=80}
ggplot(no_sports_cars) +
  geom_point(mapping = aes(x = cty, y = hwy, color = class), position = "jitter")
```

### One more scatter plot

In our first visualization of this section, we plotted `hwy` against `displ`.
In that plot, by substituting `cty` for `hwy`, we obtain a similar plot of `cty` against `displ`. 

What if we want to see now both `hwy` and `cty` against `displ`? Is it possible to merge the two plots into one?

Yes, we can do the merge easily using pivoting. Recall that `pivot_longer` combines multiple columns into one. We can create a new data frame that combines the values from `hwy` and `cty` under the name `efficiency` while specifying whether the value is from `hwy` or from `cty` under the name `eff_type`.

```{r}
no_sports_cars_pivot <- no_sports_cars %>% 
  pivot_longer(cols = c(hwy,cty), 
               names_to = "eff_type", 
               values_to = "efficiency") 
```

Then we can plot `efficency` against `displ` by showing `eff_type` using the shape and `class` using the color.

```{r warning = FALSE, fig.align="center", dpi=80}
ggplot(no_sports_cars_pivot) +
  geom_point(aes(x = displ, y = efficiency, alpha = eff_type, shape = class), 
             position = "jitter")
```

The "jitter" option makes the visualization quite busy. Let us take it away.

```{r, warning=FALSE, fig.align="center", dpi=80}
ggplot(no_sports_cars_pivot) +
  geom_point(aes(x = displ, y = efficiency, alpha = eff_type, shape = class))
```

Note the pattern in the fill strength of points as dictated by `eff_type` -- the upper region of the plot is shaded more boldly and the lower region very lightly. We leave it as an exercise to the reader to come up with some explanations as to why such a visible pattern emerges. 

<!-- you will waste more gallons in the city than highway because you are stopped at traffic signs and going from 0 to 40 many more times, which takes more gallons  --> 

## Line and Smooth Geoms

In the last section we introduced scatter plots and how to interpret them using `ggplot` with the point geom. In this section we introduce two new geoms, the point and smooth geoms, to build another (hopefully familiar) visualization: the line chart.    

### Prerequisites

We will make use of the tidyverse in this chapter, so let us load it in as usual.

```{r message = FALSE, warning = FALSE}
library(tidyverse)
```

We will study a data frame called `airmiles`, which contains data about passenger miles on commercial US airlines between 1937 and 1960.

```{r, echo = FALSE}
df_airmiles <- data.frame(
  miles = as.matrix(airmiles), date = time(airmiles))
df_airmiles
```

We will examine a toy dataset called `df` to use for visualization. Recall that we can create a dataset using `tibble`. 

```{r}
df <- tibble(x = seq(-2.5, 2.5, 0.25), 
             f1 = 2 * x - x * x + 20, 
             f2 = 3 * x - 10, 
             f3 = -x + 50 * sin(x))
df
```

### A toy data frame  

`df` has four variables, `x`, `y`, `z`, and `w`. The range of `x` is [-2.5,2.5] with 0.25 as a step width. The functions for `y`, `z`, and `w` are $2x - x^2 + 20$, $3x - 10$, and $-x+\sin(x)$, respectively. 

To visualize these three functions, we first need to *pivot* the data so that it becomes a long table. The reason for this step should become evident in a moment.  

```{r}
df_long <- df %>%
  pivot_longer(c(f1, f2, f3), names_to = "type", values_to = "y") %>%
  select(x, y, type)
df_long
```

Note how we have two variables present, `x` and `y`, annotated by a third variable, `type`, designating which function the $(x, y)$ pair belongs to.

### The line geom 

We start with visualizing `y` against `x` for each of the three functions. We can use the same strategy as `geom_point` by simply substituting `geom_line` for `geom_point`. However, we will pass an additional argument `group` to the aesthetic to inform `ggplot` which function a point comes from.   

```{r warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_long) + 
  geom_line(mapping = aes(x = x, y = y, group = type))
```

This plot is quite dull-looking and it can be hard to tell the lines apart from each other. How about we annotate each line with a color? To do this, we substitute the `group` argument for `color`. 

```{r warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_long) + 
  geom_line(mapping = aes(x = x, y = y, color = type))
```

A curious phenomenon is the variables `x` and `y` coincide with the argument names `x` and `y` inside the `aes`. So the meaning of `x` and `y` are different depending on which side of the equality sign they fall. The `y` appearing on the side of the plot refers to the attribute.  

If we are not content with the labels on the axes, we can specify an alternative using `xlab` or `ylab`. Moreover, we can further control how the line plot looks by specifying the shape, width, and type of line. The resulting effect depends on whether these arguments are passed to the *aesthetic*, as we did above with `color` and `group`, or to the `geom_line` function directly. Here is an example. 

```{r warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_long) + 
  geom_line(mapping = aes(x = x, y = y, color = type), 
            size = 2, linetype = "longdash") + 
  xlab("x values") + 
  ylab("y values")
```

Observe how the color is varied for each of the functions, but the size and type of the line is the same across all of the them. Can you tell why? If you think you got it, here is a follow-up question: what would you need to change to make *both* the color and line type different for each of the lines? 

By the way, there are many line types offered by `ggplot`. Available line types are "twodash", "solid", "longdash", "dotted", "dotdash", "dashed", and "blank".

### Combining `ggplot` calls with `dplyr`

Let us turn our attention to the function `f3` and set aside the functions `f1` and `f2` for now. We know how to do this using `filter` from `dplyr`. 

```{r}
only_f3 <- df_long %>%
  filter(type == "f3")
```

The object `only_f3` keeps only those points corresponding to the function `f3`. We could then generate the line plot as follows. 

```{r eval = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = only_f3) + 
  geom_line(mapping = aes(x = x, y = y)) 
```

However, we have discussed before how naming objects, and keeping track of them, can be cumbersome. Moreover, `only_f3` is only useful as input for the visualization; for anything else, it is a useless object sitting in memory. 

We have learned that the pipe operator (`%>%`) is useful for eliminating  redundancy with `dplyr` operations. We can use the pipe again here, this time to "pipe in" a filtered data frame to use as a data source for  visualization. Here is the re-worked code.    

```{r warning = FALSE, fig.align="center", dpi=80}
df_long %>%
  filter(type == "f3") %>%
  ggplot() + 
  geom_line(mapping = aes(x = x, y = y)) 
```

There is something unfortunate about this code: the pipe operator cannot be used when specifying the `ggplot` layers, so we have a motley mix of `%>%` and `+` symbols in the code. Keep this in mind to keep the two straight in your head: use `%>%` when working with `dplyr` and use `+` when working with `ggplot`. 

This curve bears the shape of the famous sinusoidal wave true to trigonometry. However, upon closer inspection, you may notice that the curve is actually a concatenation of many straight-line pieces stitched together. Here is another example using `df_airmiles`.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_airmiles) + 
  geom_line(mapping = aes(x = date, y = miles))
```

Is it possible to draw something smoother? For this, we turn to our next geom: the *smooth* geom. 

<!-- If you wish to show the color specifications as a legend, you can use  `scale_color_manual`.
`scale_color_manual` is a variant of `scale_color_gradient`.
You can specify a series of color names and a series of matching number of color labels and then use the color labels in `aes`.

```{r eval = FALSE}
ggplot(df, aes(x = x)) +
  geom_line(aes(y = y, color = "y(x)"), size = 1, linetype = "solid") +
  geom_line(aes(y = z, color = "z(x)"), size = 1, linetype = "dashed") +
  geom_line(aes(y = w, color = "w(x)"), size = 2, linetype = "dotted") +
  scale_color_manual("",
    breaks = c("y(x)", "z(x)", "w(x)"),
    values = c("blue", "forestgreen", "pink")) +
  xlab("x value") +
  ylab("y(x)|z(x)|w(x)")
``` 
--> 

### Smoothers

We observed in our last plots that while line geoms can be used to plot a line chart, the result may not be as smooth as we would like. An alternative to a line geom is the *smooth* geom, which can be used to generate a *smooth line plot*. 

The way to use it is pretty much the same as `geom_line`. Here is an example using the toy data frame, where the only change made is substituting the geom. 

The argument `se = FALSE` we pass to `geom_smooth` is to disable a feature that displays confidence ribbons around the line. While these are certainly useful, we will not study them in this course.  

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_long) + 
  geom_smooth(aes(x = x, y = y, color = type), 
              se = FALSE)
```

Observe that the piece-wise straight line of the sine function now looks like a proper curved line.

It is possible to mix line and smooth geoms together in a single plot.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_long) + 
  geom_smooth(mapping = aes(x = x, y = y, color = type), se = FALSE) + 
  geom_line(mapping = aes(x = x, y = y, color = type))
```

Notice the slight deviations along the sine curve. The effect is more apparent when we visualize `airmiles`.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_airmiles) + 
  geom_point(mapping = aes(x = date, y = miles)) + 
  geom_line(mapping = aes(x = date, y = miles)) + 
  geom_smooth(mapping = aes(x = date, y = miles), 
              se = FALSE)
```

The line geom creates the familiar line graph we typically think of while the smooth geom "smooths" the line to aid the eye in seeing overall patterns; the line geom, in contrast, is much more "ridgy".

`geom_smooth` uses statistical methods to determine the smoother. One of the methods that can be used is *linear regression*, which is a topic we will see study in detail towards the end of the course. Here is an example.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = df_airmiles) + 
  geom_point(mapping = aes(x = date, y = miles)) + 
  geom_line(mapping = aes(x = date, y = miles)) + 
  geom_smooth(mapping = aes(x = date, y = miles), 
              method = "lm", se = FALSE)
```

Let us close our discussion of line and smooth geoms using one more example of the smooth geom. 

### Observing a negative trend 

The smooth geom can be useful to confirm the negative trend we have observed in the `mpg` data frame.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy), 
                se = FALSE)
```

Here we have layered *two* geoms in the same graph: a point geom and a smooth geom. Note how the outlier points have influenced the overall shape of the curve to bend upward, muddying the claim that there is a strong negative trend present in the data.

Armed with our understanding about sports cars, we can adjust the visualization by setting aside points with `class == "2seater"`.         

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy), 
                se = FALSE)
```

This plot shows a much more graceful trend downward.

Before moving to the next topic, we point out some redundancy present in our plotting code. Namely, we have defined the same mapping for `x` and `y` in two different places.

This could cause some unexpected surprises when writing code: imagine if we wanted to change the y-axis to `cty` instead of `hwy`, but we forgot to change both occurrences of `hwy`. This can be amended by moving the mapping to `ggplot()`.     

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth(se = FALSE)
```

We can also write this more concisely by omitting some keywords as below, and the result would be the same.

```{r eval = FALSE, message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point(aes(color = class)) + 
    geom_smooth(data = filter(mpg, class == "2seater"), se = FALSE)
```

We can extend this idea further to specify different `data` for each layer. Here, the smooth geom gives a smoother for only a subset of the data, the sports cars.

```{r message = FALSE, warning = FALSE, fig.align="center", dpi=80}
ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point(aes(color = class)) + 
    geom_smooth(data = filter(mpg, class == "2seater"), se = FALSE)
```


## Visualizing Categorical Variables

The point, line, and smooth plots are for viewing relations among numerical variables. As you are well aware, numerical variables are not the only type of variables in a data set. There are variables representing categories, and we call them *categorical variables*.

A categorical attribute has a fixed, finite number of possible values, which we call *categories*. The categories of a categorical attribute are distinct from each other.

A special categorical attribute is a *binary category*, where there are exactly two values. A binary category that we are probably the most familiar with is the *Boolean category*, which has "true" and "false" as its values. Because of the familiarity, we often identify a binary category as a Boolean category.

In datasets, categories in a categorical attribute are sometimes called *levels* and we refer to such a categorical attribute as a *factor*. Sometimes, categories are whole numbers 1, 2, ..., representing indexes.
Such cases may require some attention when processing with R, because R may think of the variables as numbers.

We have seen examples of categorical variables before. The `class` attribute in the `mpg` data set is one.

### Prerequisites

As before, let us load `tidyverse`. Moreover, we will make use of datasets that are not available in `tidyverse` but are available in the package `faraway`. So, we load the package too.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(faraway)
```

### The `happy` and `diamonds` data frames

The table `happy` contains data on 39 students in a University of Chicago MBA class. 

```{r}
happy
```

Armed with what we have learned about `ggplot2`, we can begin answering questions about this data set using data transformation and visualization techniques. For instance, which "happiness" scores are the most frequent among the students? Moreover, can we discover an association between feelings of belonging and higher scores of happiness? How about family income?  

Before we inspect the `happy` data set any further, we will also consider another table `diamonds`, which contains data on almost 54,000 diamonds.   

```{r}
diamonds
```

The *values* of the categorical variable *cut* are "fair", "good", "very good", "ideal", and "premium". We can look at how many diamonds are in each category by using `group_by()` and `summarize()`.

```{r, message = FALSE}
diamonds %>%
  group_by(cut) %>%
  summarize(count = n())
```

The table shows the number of diamonds of each cut. We call this a *distribution*. A distribution shows all the values of a variable, along with the frequency of each one. Recall that the summary does not persist on the `diamonds` data set and so the dataset remains the same after summarization.

### Bar Chart

The bar chart is a familiar way of visualizing categorical distributions.
Each category of a categorical attribute has a number it has an association with, and a bar chart presents the numbers for the categories using bars, where the height of the bars represent the numbers.

Typically, the bars in a bar chart appear either all vertically or all horizontally with an equal space in between and with the same height but expanding horizontally (that is, the non-variable dimension of the bars).

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(diamonds, aes(x = cut)) + 
  geom_bar()
```

The x-axis displays the values for the *cut* attribute while the y-axis says "count". The label "count" is the result of `geom_bar()` generating bars. Since the number of observations is greater than there are categories, `geom_bar()` decides to count the occurrences of each category.
The word "count" says that it is the result of counting.

We often call the inner working of the `geom_bar()` (and other geom functions) for number generation __stat__. Thus, `ggplot2` transforms the raw table to a new dataset of categories with its corresponding counts. From this new table, the bar plot is constructed by mapping `cut` to the x-axis and `count` to the y-axis. 

The default stat `geom_bar()` uses for counting is `stat_count()`, which counts the number of cases at each `x` position. If the counts are already present in the dataset and we would prefer to instead use these directly  for the heights of the bars, we can set `stat = "identity"`. For instance, consider this table about popular pies sold at a bakery. The "count" is already present in the `sold` variable. 

```{r, fig.align="center", dpi=80, warning = FALSE}
store_pies <- tribble(
  ~pie,             ~sold,
  "Pecan",            906,
  "Key Lime",         620,
  "Pumpkin",          202,
  "Apple",            408,
  "Mississippi mud",  551
)
ggplot(data = store_pies) +
  geom_bar(mapping = aes(x = pie, y = sold), stat = "identity")
```

Note how we provide both `x` and `y` aesthetics when using the `identity` stat. 

### Towards numerical variables 

Let us turn to the `happy` data frame. We can consider the *categories* to be points on the 10-point scale, and the *individuals* the students in each interval. Let us determine this distribution using `group_by` and `sumarrize`.

Below, we take the `happy` data set and execute grouping by `happy`. The category for the happy value is `happiness` in this new dataset `happy_students`. We summarize in terms of the counts `n()` and we state the count as an attribute `number`.

```{r out.width = "50%", fig.align="default", message = FALSE}
happy_students <- group_by(happy, happiness = happy) %>% 
  summarize(number = n())
happy_students
```

We can now use this table, along with the graphing skills that we acquired above, to draw a bar chart that shows which scores are most frequent among the 39 students.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = happiness, y = number), stat = "identity") +
  xlab("Happy score") + 
  ylab("Count")
```

Here R treats the happy score as numerical values. That is the reason that we see 2.5, 5.0, 7.5, and 10.0 on the x-axis. Let us inform R that these are indeed categories by treating `happiness` as a factor. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = as.factor(happiness), y = number), stat = "identity") +
  xlab("Happy score") + 
  ylab("Count")
```

We can also reorder the bars in the descending order of `number`.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = reorder(happiness, desc(number)), y = number), 
           stat = "identity") +
  xlab("Happy score") + 
  ylab("Count")
```

There is something unsettling about this chart. Though it does answer the question of which "happy" scores appear most frequently among the students, it doesn't list the scores in chronological order.

Let us return to the first plot.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = as.factor(happiness), y = number), stat = "identity") +
  xlab("Happy score") + ylab("Count")
```

Now the scores are in increasing order.

We can attempt an answer to our second question: is there an association between feelings of belonging and "happy" scores? Put another way, what relationship, if any, exists between `love` and `happy`? For this, let us turn to positional adjustments in `ggplot`. 

### More on positional adjustments

With point geoms we saw the usefulness of the "jitter" position adjustment to overcome the problem of overplotting. Bar geoms similarly benefit from positional adjustments. For instance, we can set the `color` or `fill` of a bar plot.

```{r eval = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

The legend that appears says "as.factor(happy)", because we used the value for coloring. We can change the title with the use of `labs(fill = ...)` ornamentation.

```{r eval = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy))) + 
  abs(fill="happy")
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy))) + 
  labs(fill="happy")
```

To make this code work, note how the parameter passed to the `color` and `fill` aesthetic is converted to a factor, or categorical variable, via `as.factor()`. As discussed, the `happy` variable is *numerical*. However, `ggplot2` can only color or fill a bar chart based on a categorical variable.    

Something interesting happens when the fill aesthetic is mapped to another variable other than `happy`, e.g., `love`.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) +
  labs(fill = "love")
```

This visualization produces a "stacked" bar chart! Each bar is a composite of both `happy` and `love`. It also reveals something else that is interesting: feelings of belonginess are associated with higher marks on the "happy" scale. While we must maintain caution about making any causative statements at this point, this visualization demonstrates that bar charts can be a useful aid when exploring a dataset for possible relationships.

The stacking is performed by the position adjustment specified by the `position` argument. Observe how the bar chart changes with these other options: 

* `position = "fill"` makes each bar the same height. This way we can compare proportions across groups. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "fill")  +
  labs(fill = "love")
```

* `position = "dodge"` places the stacked bars directly *beside* one another. This makes it easier to compare individual values. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "dodge")+
  labs(fill = "love")
```

We can adjust the values of the x-axis to whole numbers using `as.factor` again. We can also the title "relation between happiness and love".

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = as.factor(happy), fill = as.factor(love)), position = "dodge") +
  xlab("Happy Score") +
  labs(fill = "love") +
  labs(title = "relation between happiness and love")
```

Bar charts are intended as visualizations of categorical variables. When the variable is numerical, the numerical relations between its values have to be taken into account when we create visualizations. That is the topic of the next section. Before ending the discussion here, we turn to one more important piece of `ggplot2` magic.  

### Coordinate Systems 

We noted earlier that one of the motifs of any `ggplot2` plot is its coordinate system. In all of the `ggplot2` code we have seen so far, there has been no explicit mention as to the coordinate system to use. Why? If no coordinate system is specified, `ggplot2` will default to using the Cartesian (i.e., horizontal and vertical) coordinate system. In Cartesian coordinates, the `x` and `y` coordinates are used to define the location of every point in the dataset, as we have just seen. 

This is not the only coordinate system offered by `ggplot2`, and learning about other coordinate systems that are available can help boost the overall quality of a visualization.

* `coord_flip()` flips the `x` and `y` axes. For instance, this can be useful when the x-axis labels on a bar chart overlap each other.  

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip()
```


* `coord_polar()` uses polar coordinates. It is useful for plotting a Coxcomb chart. Note the connection between this and a bar chart.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_polar()
```

* `coord_cartesian(xlim, ylim)` can be passed arguments for "zooming in" the plot. For instance, we may want to limit the height of very tall bars (and, similarly, the effect of very small bars) in a bar chart by passing in a range of possible y-values to `ylim`.   

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip() +
  coord_cartesian(ylim=c(1,10))
```

This can also be a neat trick for eliminating the (awkward) gap between the bars and the x-axis :-)


## Visualizing Numerical Distributions 

Many of the variables that data scientists study are *quantitative* or *numerical*, like the displacement and highway fuel efficiency, as we have seen before. Let us go back to the `mpg` data set and learn how to visualize its numerical values.

### Prerequisites

As before, let us load `tidyverse`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### A slice of `mpg`

In this section we will draw graphs of the distribution of the numerical variable in the column `hwy`, which describes miles per gallon of car models on the highway. For simplicity, let us create a subset of the data frame that includes only the information we need.

```{r}
mpg_sub <- select(mpg, manufacturer, model, hwy) 
mpg_sub
```

### What is a Histogram?

A *histogram* of a numerical dataset looks very much like a bar chart, though it has some important differences that we will examine in this section. First, let us just draw a histogram of the highway miles per gallon.

The geom histogram generates a histogram of the values in a column. The histogram below shows the distribution of `hwy`. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg_sub, aes(x = hwy)) +
  geom_histogram(fill = "darkcyan", color = "gray")
```

Note that, like bar charts, the mapping for the y-axis in the aesthetic is absent. In its place, `ggplot` computes a count for each "bin" in the histogram.  

### The Horizontal Axis and Bar Width

In a histogram plot, we group the amounts into groups of contiguous (and thus, non-overlapping) intervals called bins. The histogram function of `ggplot` use the _left-out, right-in_ convention in bin creation. What this means is that the interval between a value $a$ and a value $b$, where $a<b$, includes $b$ but not $a$. The convention does not apply the smallest bin, which has the left-end as well. Let us see an example. 

Suppose we divide the interval from $0$ to $100$ into four bins of an equal size. The end points of the intervals are $0, 25, 50, 75$, and $100$.

* Bin No.1 contains all the values between $0$ and $25,
* Bin No.2 contains all the values between $25$ and $50$ except the exact value of $25$,
* Bin No.3 contains all the values between $50$ and $75$ except the exact value of $25$, and
* Bin No.4 has all the values between $75$ and $100$, excluding the exact value of $75$.

If you happen to be familiar with open and close intervals, the four intervals are: $[0,25], (25,50], (50,75]$, and $(75,100]$.

So, we have values $0.0, 4.7, 5.5, 25.0, 25.5, 49.9, 50.0, 70.0, 72.2, 73.1, 74.4, 75.0, 99.0$, then Bin No.1 has the four values, from $0.0$ to $25.0$, Bin No.2 has three values, from $25.5$ to $50.0$, Bin No.3 has five, from $70.0$ to $74.4$, and Bin No. 4 has just $99.0$.

Histograms are in some sense, an extended version of the bar plot where the number of bins are adjustable, where the height represent (in the case of vertical plots) the counts and the width is the same for all the bars.

In the above histogram, we see that the leftmost and the rightmost bars encompass 30 bins (some of them are obviously empty). We can also see that no car models had less than 10 or greater than 50 highway miles per gallon. Like the `geom_bar()` function, the `geom_histogram()` computes the largest value and the smallest value appearing in the dataset.

The end points of the bin-defining intervals are difficult to recognize just by looking at the chart. It is a little harder to see exactly where the ends of the bins are situated. For example, it is not easy to pinpoint exactly where the value 19 lies on the horizontal axis. Is it in the interval for the bin that stands on the line 20 on the x-axis or the one immediately to the left of it? Hard to tell...

We can use, for a better visual assessment, our custom set of intervals as the bins. The specification of the bin set is by way of stating `breaks = BINS` as an argument in the call for `geom_histogram()`, where `BINS` is a sequence of breaking points. 

Recall that we can define a numerical series from a number to another with fixed gap amount using function `seq()`. Below, we create a numerical series using `seq()` and then specify to use the sequence in the break points.

The sequence starts at 10 and ends at 10 with the gap of 1. Using the convention of end points in R, the sequence produces 40 intervals, from 10 to 11, from 11 to 12, ..., from 49 to 50, with the right end inclusive and the left end exclusive, except for the leftmost interval containing 10.

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,1)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(fill = "darkcyan", color = "gray", breaks = bins)
```

<!--[-->
The tallest histogram bar is the one immediately to the right of the 25 white line on the x-axis, so it corresponds to the bin $(25,26]$. <!--)-->

Let us try using a different step size, say 5.0.

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,5)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(fill = "darkcyan", color = "gray", breaks = bins)
```

<!--[[-->
We observe two tall bars at (15,20] and at (25,30]. <!--))-->


### The Counts in the Bins 

We can record the count calculation that `geom_histogram` carries out using the `cut()` function. The function takes an attribute and the bin intervals as its arguments and generates a table of counts.

The end point convention applies here, but in the data frame presentation, the description does not use the left square bracket for the lowest interval - it uses the left parenthesis like the other intervals.

Below, we create a new attribute `bin` that shows the bin name as its value using the `cut(hwy, breaks = bins)` call, then using `count` compute the frequency of each bin name in the `bin` attribute without dropping the empty bins in the counting result, and print the result on the screen.

```{r}
bins <- seq(10,50,1)
binned <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins)) %>%
  count(bin, .drop = FALSE) %>%
  print()
```

Note that the label for 10 to 11 (appearing at the beginning) has the left parenthesis.

If you want to ignore the empty bins, change the option of `.drop = FALSE` to `.drop = TRUE` or take the option away.

```{r}
bins <- seq(10,50,1)
binned <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins)) %>%
  count(bin, .drop = TRUE) %>%
  print()
```

We can try the alternate bin sequence, whose step size is 5.

```{r}
bins2 <- seq(10,50,5)
binned2 <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins2)) %>%
  count(bin, .drop = TRUE) %>%
  print() 
```


### Density Scale 

In the histogram that `ggplot` generates, what the horizontal axis represents, and what the left and right borders of each bar represents, are clear, except that depending on the choices of the bin sequence, the exact values the borders represent may be difficult to discern from the plot. 

So far, the height of the bar has been the count, or the number of elements that are found in some bin. However, it can be useful to instead look at the *density* of points that are contained by some bin. When we plot a histogram in this manner, we say that it is in *density scale*. 

In density scale, the height of each bar is the percent of elements that fall into the corresponding bin, _relative to the width of the bin_. Let us explain this using the following calculation.

We use the bin width of 5, which we will refer to using `bin_width`. The meaning of assigning 5 to the bin width is that each bin covers 5 consecutive units of the `hwy` value. Then we create a histogram with unit-size bins, divide the bars into consecutive groups of 5, and then even out the heights of the bars in each group.

More specifically, we execute the following steps.

* Using `bin_width` as a parameter, we create a sequence `bin2` of bin boundaries from 10 to 5.
* Like before, when we "cut" the `hwy` values using `bins` as break points (the `mutate()` call and its subsequent `count()` call), we get the bins and their counts under variables `bin` and `n`, respectively.
* We obtain the proportions of the counts in the entire cars appearing in the data set `mpg_sub` by dividing the counts by `nrow(mpg_sub)`.
* We then for each bin, split the proportion in the bin among the 5 units the bin contains (we use the division by `bin_width` instead by the division by `5`).

```{r}
bin_width = 5
bins2 <- seq(10,50,bin_width)
binned2 <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins2)) %>%
  count(bin, .drop = TRUE) %>%
  mutate(proportion = n/nrow(mpg_sub)) %>%
  mutate(density = proportion/bin_width) %>%
  print()
```

Now let us recall the plot using the bins.
We see that the density values we have calculated match the height of the bars.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), 
                 fill = "darkcyan", color = "gray", breaks = bins2)
```

The `aes(y = ..density..)` call requests computation of "density" as the y-axis.

### Unequal Bins

An advantage of the histogram over a bar chart is that a histogram can contain bins of unequal width. Below, the values in the `hwy` column are binned into three uneven categories.

```{r dpi=80,  fig.align="center", message = FALSE}
uneven_bins <- c(10, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), fill = "darkcyan", color = "grey", 
                 breaks = uneven_bins, position = "identity")

```

Here are the counts in the three bins.

```{r}
mpg_sub %>%
  mutate(bin = cut(hwy, breaks = uneven_bins)) %>%
  count(bin, .drop = FALSE)
```

Although the ranges (10, 15] and (30, 45] have nearly identical counts, the bar over the former is twice as tall as the latter because it is only half as wide. This is the effect of flattening we have explained previously; that is, we flatten the bar height over the units in each bin.

### Gotchas with Count Scale

There are some discrepancies to note between a histogram in density scale and a histogram with count scale. While the count scale may be easier to digest visually than density scale, the count scale can be misleading when using bins with different widths. The problem: the height of each bar does *not* account for the difference in the widths of the bins.  

Let us compare the following two histograms that use uneven bins. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(fill = "darkcyan", color = "grey", 
                 breaks = uneven_bins, position = "identity")
```

```{r dpi=80,  fig.align="center", message = FALSE}
uneven_bins <- c(10, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), fill = "darkcyan", color = "grey", 
                 breaks = uneven_bins, position = "identity")
```

Note how the histogram in count scale *exaggerates* the height of the $(30, 45]$ bar. The height shown is simply the number of car models in that bin with no regard to the width of the bin. While both the $[10, 15]$ and $(30, 45]$ bars may have the same number of car models in the bin, the *density* of the $[10, 15]$ bar is greater because there are more elements contained by a smaller bin width. Put another way, the $(30, 45]$ bar can provide more coverage because it is so "spread out", i.e., its bin width is much larger than that of the $[10, 15]$ bar. 

For this reason, we will prefer to plot our histograms in density scale rather than count scale.

### Histograms and positional adjustments 

As with bar charts and scatter plots, we can use positional adjustments with histograms. 

Below, we use bins of width 5 and then color the portions of the bars according to the classes. To make the breakdown portions appear on top of each other, we use the  `position = "stack"` adjustment. 

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,5)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(fill = class), breaks = bins, position = "stack")
```

Instead of stacking, the bars can be made to appear side by side.

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,5)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(fill = class), breaks = bins, position = "dodge")
```





<!--
Once it receives the `aes` specification, `ggplot` places coordinates so it can plot any combination of `x` and `y`.
To accomplish the placement, `ggplot` examines the values appearing in the two variables to find the maximum and the minimum appearing in the variables.
Thus, the coordinate determination is possible without having to specify a geom; that is, it is possible to include the `mapping = aes(...)` as an argument in `ggplot`.
The example exactly does this.

By telling `ggplot` which data to use and which variables of the data to use, you can generate a coordinate plot. 

```{r, eval = FALSE, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = `displ`, y = `hwy`))
```
Once `ggplot` has the data and the coordinate information, you do not have to state the mapping information any more - it suffices to tell you need a `geom_point`.
`ggplot` then creates a scatter plot using the present specification of x and y.

```{r, eval = FALSE, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point()
```

It is also possible to restate the data, the mapping, or both in the `geom_point` call.
A convenient feature of `ggplot` is that once you have specified `data` or `aes`, you do not have to specify it again as long as you keep using the same setting.
It means that you have a lot of freedom in saying where you want to state the data you plot about and which coordinates you use.
The example again produces the same plot as the first.
The difference this time is that the code specifies the `data` and `aes` both in the `ggplot` call and the `geom_point` call.


```{r, eval = FALSE, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy))
```

```{r, eval = FALSE, fig.align="center", dpi=80, warning = FALSE}
ggplot(mpg2) + geom_boxplot(aes(x = as.factor(class), y = hwy))
```

pickups and suv are particularly bad; the regions that are busy, we can see those are from classes that are competing for the same range; use box plot for continuous vs discrete 

-->