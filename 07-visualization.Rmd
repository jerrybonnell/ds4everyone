---
output:
  pdf_document: default
  html_document: default
---
# Visualization 

As you develop familiarity in processing data, you learn how to develop intuition from the data at hand by glancing at its values.
Unfortunately, there is only so much you can do with glancing at values.
There is a substantial limitation to what you can obtain when the data at hand is so large.
Visualization is a powerful tool in such cases.
In this chapter we introduce the `ggplot2` package for visualization.
The `ggplot2` package is part of `tidyverse`, and like other packages, it is suffifient to load the `tidyverse` package.

## Visualizing with `ggplot2`

R provides many facilities for creating visualizations.
The most sophisticated of all that are available is `ggplot2`.
The structure of visualization with `ggplot2` is by way of *grammar of graphics*.
Although the name of the package is `ggplot2` the function we call to specify the data is `ggplot()`.
It is a bit confusing, but we will be loading the meta-package `tidyverse`, we can be totally oblivious to the name difference.
You can consult this [cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf) for quick referencing.

Let us begin by loading `tidyverse`.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

Let us use the `mpg` data set as our source.
`mpg` is a data set by the US Environmental Protection Agency that shows information about 38 models of car between 1999 and 2008.
We visited this data set earlier.
The table `mpg` has 234 rows and 11 columns. Use `?mpg` open its help page. Let's have a look at a snapshot of the data again.  

```{r}
mpg
```

Another way to preview the data is by using `glimpse()`. 

```{r}
glimpse(mpg)
```

<!--
__Terminology.__ As we introduced in the previous chapter,  *variable* is a synonym for attributes.
The term variable emphasizes that the feature can have different values for different individuals – the numbers of movies that actors have been in varies across all the actors.

Variables that have numerical values, such as 'highway miles per gallon' or 'engine displacement' are called *quantitative* or *numerical* variables.
-->

### The layered grammar of graphics

The grammar of graphics in R states that it is possible to build every plot from the same few components, which we call *layers*:

* (1) a __data set__ upon which we will build plots,
* (2) a __coordinate system__, which we use as references for plotting, and
* (3) a series of geometrical objects, which we call __geoms__.

There are many geoms available in `ggplot`.
The most popular and intuitive to our senses are bar charts, line charts, and scatter plots.
The geom types corresponding to these charts are *bar* geoms, *line* geoms, and *point* geoms, respectively.
To specify the underlying layer, we use the function `ggplot()`.
To place a geom, we use the function `geom_XXX` where `XXX` is the name of the geom type (for example, `line`).
We specifying the first two layers, (1) and (2), using arguments `data = ...` and `mapping = ...`.
The value that follows `data = ` must be a data frame, for example, `mpg`.
The value that follows `mapping = ` is the *aesthetic*, which specifies the properties of the plotting layer and the the properties of each geom.
`ggplot` uses the function `aes()` for specifying aesthetics.
We use `aes()` to specify the attributes to plot using the expression `mapping = aes(...)`.

### Scatter Plots 

Let's start our exploration with the __point__.

A *scatter plot* is a plot that presents the relation between two numerical variables.
In other words, a scatter plot of variables `A` and `B` draws data from a collection of pairs `(a,b)`, where each pair comes from a single observation in the data set.
The number of pairs you plot can be one or more.
There is no restriction on the frequencies we observe the same pair, the same `a`, and the same `b`.
<!--You saw an example of a scatter plot in an early section where we looked at the number of periods and number of characters in two classic novels. -->
We will use a scatter plot here to visualize the relationship between the highway fuel efficiency (`hwy`) and the displacement of its engine (`displ`).

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```
Each point on the plot is the pair of values of one car in the data set.
Note that there are quite a few groups of points that align horizontally and quite a few groups of points that align vertically.
The former are groups that share the same (close to the same) `hwy` values with each other, the latter are groups that share the same (close to the same) `displ` values with each other.

We notice several things in the code:

* There are one `ggplot` and one `geom_point.
* The `ggplot` call preceded the `geom_point` call.
* The plus sign `+` connects between the two calls.
* A `data` specification appears in the `ggplot` call.
* A `mapping` specification appears in the `geom_point` call.

The semantics of the code is as follows:

* Instruct `ggplot` to get ready for creating plots using `mpg` as the data.
* Instruct `geom_point` to create a plot using `displ` as the x-axis and `hwy` as the y-axis, where the two attributes are from the data frame `mpg`.

Once it receives the `aes` specification, `ggplot` places coordinates so it can plot any combination of `x` and `y`.
To accomplish the placement, `ggplot` exams the values appearing in the two variables to find the maximum and the minimum appearing in the variables.
Thus, the coordinate determination is possible without having to specify a geom; that is, it is possible to include the `mapping = aes(...)` as an argument in `ggplot`.
The example exactly does this.
By telling `ggplot` which data to use and which attributes of the data to use, you can generate a coordinate plot. 

```{r, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = `displ`, y = `hwy`))
```
Once `ggplot` has the data and the coordinate information, you do not have to state the mapping information any more - it suffices to tell you need a `geom_point`.
`ggplot` then creates a scatter plot using the present specification of x and y.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point()
```

It is also possible to restate the data, the mapping, or both in the `geom_point` call.
A convenient feature of `ggplot` is that once you have specified `data` or `aes`, you do not have to specify it again as long as you keep using the same setting.
It means that you have a lot of freedom in saying where you want to state the data you plot about and which coordinates you use.
The example again produces the same plot as the first.
The difference this time is that the code specifies the `data` and `aes` both in the `ggplot` call and the `geom_point` call.


```{r, fig.align="center", dpi=80}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy))
```
Also, we can omit the prefix `data = ` and `mapping =`.
The example below again does the same.

```{r, fig.align="center", dpi=80}
ggplot(mpg) +
  geom_point(aes(x = displ, y = hwy))
```

__Coloring Points__

Let us go back to the plot and see where the points are.
It appears to us that the points are following some downward trend.
We can imagine two parallel down slopes encompassing most of the points.
`ggplot` can assign colors to its points.
You can specify the attribute for `ggplot` to use to determine the colors.
The plot below instructs `ggplot` to use the `class` attribute.
You can make the specification in the `aes` of `geom_point`.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

It looks like the points in the "2seater" class appear to the middle right,
Let us get rid of them to create a neqw data set.

```{r}
mpg1 <- filter(mpg, class != "2seater")
ggplot(data = mpg1) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

After the removal of the "2seater" class, the downward trend appears more vivid.

```{r}
unique(mpg$manufacturer)
```

Can we develop more insights using coloring?
Using the `mutate` function, we can create a new attribute `japanee`, which gives whether the manufacturer is one of Honda, Nissan, Subaru, and Toyota.
We create a new data set with the addition of `japanese`.

```{r}
mpg1 %>% mutate(japanese = ( manufacturer == "honda" | manufacturer == "nissan" | manufacturer == "subaru" | manufacturer == "toyota") ) -> mpg2
```

Now let us create two new plots, with two difference coloring strategies: one with `japanese` and the other with `cyl`.

```{r}
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy, color = japanese))
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cyl))
```

The plot with the `japanese` attribute as the coloring attribute is in a similar format as the one with the `class` attribute.
For the other plot, the legend appearing to the right of the dots looks very different.
Instead of dots showing the color specification, it uses a bar with gradation in blue.
The reason is that `ggplot` thinks that the `cyl` attribute is `double`.
We can resolve the issue by creating a string-type attribute representing the `cyl` value.
Below, we create a new attribute `cylname` by way of `mutate`.
The formula for `cylname` is `as.character(cyl)`, which converts numerals to characters.

```{r}
mpg2 %>% mutate(cylname = as.character(cyl)) -> mpg3
ggplot(data = mpg3) +
  geom_point(mapping = aes(x = displ, y = hwy, color = cylname))
```


<!--
To wit, we can add the following two lines.
There are two downward lines that encompass most points.
```{r, fig.align="center", dpi=80}
line1 <- function(x) { return(35 - 5.5 * x) } 
line2 <- function(x) { return(50 - 5.5 * x) } 
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_point() +
  geom_line(data = mpg, aes(x = displ, y = line2(displ))) +
  geom_line(data = filter(mpg,displ<= 4), aes(x = displ, y = line1(displ)))
```

-->

When we see that the plot of `hwy` against `displ`, we notice that there is a some sort of downward trend, i.e., the bigger engine a car has, the less fuel efficient it is.
That is the advantage of using visualization.
Human eyes are able to recognize possible *associations* between them.
Typically the associations human eyes find are: the dots get higher as we go to the right, the dots get lower as we go the right, the dots look like a U-shape in which the half-way point on the horizontal axis appear to be at the lowest, the dots look oike an inverted U-shape in which the half-way point on the horizontal axis appear to be at the highest, and the dots are everyone with no visually observable concentration of dots.
Of such patterns, the first two and the last one are the easiest of observed with naked eyes. We call the first one the positve association, the second the negative association, and the last no association.
When we make such visual categorization of the patterns, or the lack thereof, there are points that are conspicuously out of place in terms of the categorization we make.
We call such out-of-place points *outliers*.
An intuitive nature of outliers is that the points we plot collectively pronounce the association between the two variables more strongly without them.

Can we add anything to the association examination with the two dimensional scatter plots?
One possibility is to color the points according to some cateogry that appears in the data set.
The variable "class" is a categorical one, and so we can use it as a variable for determining the coloring.
To specifying the coloring scheme, you have only to specify the coloring category to the `aes` specification using the argument `color=NAME` where `NAME` is the name of the variable to use for the coloring.
The color choice is automatic; that is, `ggplot2` chooses the colors according to the values appearing in the variable.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

There are seven categories in the `class` attribute.
Those names appear in the color specification legend.
To those whose visual color sensitivity is high, this is a very effetive approach.

With the color assignment, the outliers look more out of place than without.
Which ones look to be outliers?
To the authors of the text, they are (a) the two appear about the horizontal line of 40 with x less than 2, and (b) the six with `x` greater than 5 and `y` between 20 and 30.
Let us remove those points before plotting.
In the code below, we create a data set `mpg2` after excluding those outlier points.

```{r, fig.align="center", dpi=80}
mpg2 <- mpg %>% filter(hwy<40) %>% filter(displ <= 5 | hwy <= 20)
ggplot(data = mpg2) +
  geom_point(aes(x = displ, y = hwy, color = class))
```

Note that our filtering process eliminates the points in the "2seater" class, and so the number of classes decreases from seven to six.
Now the visualization pronounces the negative association between displacement and highway mileage more clearly.
We can even bold to say that sports cars are outliers in the negative association!
Even though sports cars have larger engines, they are more efficient than other cars with more engines because of their smaller body form, compared to SUVs.

__Other types of aesthetics.__

It is possible to use a different type of articular than the coloring.
include other types of aesthetics other than `color`.
They are `alpha`, which is the darkness of the color, and `shape`, which is the shape of point.

The two plots we present below use `alpha` and `shape`, respectively.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```

It is possible to combine these.
Below, we use `color` and `shape` concurrently.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy, shape = class, color = class))
```

### Positional Adjustments

The careful reader will observe that there are 234 entries in the data set. However, much less (only 109 to be exact) appears in the initial (before filtering) scatter plot.
The issue is that the points are rounded so the points appear on a grid and many points overlap each other.
We refer to the problem as __overplotting__.
This makes it hard to see where the mass of the data is. 

It is possible to solve the overplotting problem by "jittering", which is to give some wiggling to the locations dots representing the points.
We specify the use of jitters by inserting the argument `position = "jitter"` in the aesthetics.
Since there are many directions along which `ggplot2` can move a point, we can anticipate that `ggplot2` is unlikely to move two points to the same locations.
Thus, jittering spreads the points out.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg2) +
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

### Line Graphs

Line graphs are among the most common visualizations.
We often use line graphs to study chronological trends and patterns.
For instance, we can use a line graph to study `airmiles`, which contains data about passenger miles on commercial US airlines between 1937 and 1960. 

```{r, echo = FALSE}
df_airmiles <- data.frame(
  miles = as.matrix(airmiles), date = time(airmiles))
```

```{r echo=FALSE, fig.align="default", message=FALSE, out.width="50%"}
ggplot(data = df_airmiles) + 
  geom_line(mapping = aes(x = date, y = miles))
ggplot(data = df_airmiles) + 
  geom_smooth(mapping = aes(x = date, y = miles))
```

Notice that two charts appear as the result since we call `ggplot` twice.
The line geom creates the familiar line graph we typically think of while the smooth geom "smooths" the line to aid the eye in seeing overall patterns; the line geom, in contrast, is much more "ridgy".
`geom_smooth` uses a mathematical method to determine the smooth line.
You can instruct `geom_smooth` to use a specific method, but what methods are available and how to state the selection is beyond the scope of this course.
`geom_smooth` also produces a ribbon over the line.
The ribbon is for showing the range of possibilities, meaning that all smooth lines that stay inside the ribbon are possibilities with the thick line in the center.

The smooth geom can be useful to confirm the negative trend we have observed in the `mpg` data frame.

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

Here we have layered *two* geoms in the same graph: a point geom and a smooth geom.
Note how the outlier points have influenced the overall shape of the curve to bend upward, muddying the claim that there is a strong negative trend present in the data.
Armed with our understanding about sports cars, we can adjust the visualization by setting aside points with `class == "2seater"`.         

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

This plot shows a much more graceful trend downward.

Before moving to the next topic, we point out some redundancy present in our plotting code.
Namely, we have defined the same mapping for `x` and `y` in two different places.
This could cause some unexpected surprises when writing code: imagine if we wanted to change the y-axis to `cty` instead of `hwy`, but we forgot to change both occurrences of `hwy`. This can be amended by moving the mapping to `ggplot()`.     

```{r, eval = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(x = displ, y = cty, color = class)) + 
    geom_smooth(aes(x = displ, y = cty)) +
    geom_smooth(aes(x = displ, y = hwy))
```

We can extend this idea further to specify different `data` for each layer. Here, the smooth geom displays only a subset of the data, the sports cars.  

```{r, eval = FALSE, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

We can also write this more concisely by omitting some keywords:

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point(aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

In the rewritings we have taken here, the same effect is obtained. 

## Visualizing Categorical Distributions 

Data come in many forms that are not numerical. Data can be pieces of music, or places on a map. They can also be categories into which you can place individuals. Here are some examples of *categorical* variables.

* The individuals are pies sold, and the variable is the type of pie.
* The individuals are diamonds, and the variable is the quality of the cut.
* The individuals are car manufacturers, and the variable is the class of the car, e.g., "compact", "SUV",  and "pickup."
* The individuals are survey respondents, and the variable is the response they choose from among "Not at all satisfied," "Somewhat satisfied," and "Very satisfied."

### Prerequisites

This section will continue to make use of `ggplot2`, so we will need the tidyverse. Moreover, we will make use of datasets that are not available in the tidyverse, but are available in the package `faraway`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(faraway)
```

### The `happy` and `diamonds` data frames

The table `happy` contains data on 39 students in a Univeristy of Chicago MBA class. 

```{r}
happy
```

Armed with what we have learned about `ggplot2`, we can begin answering questions about this dataset using table manipulation and visualization techniques. For instance, which "happiness" scores are the most frequent among the students? Moreover, can an association be determined between feelings of belongingness and higher scores of happiness? How about family income?  

Before we inspect this dataset any further, we will also consider another table called `diamonds`, which contains data on almost 54,000 diamonds.   

```{r}
diamonds
```

The *values* of the categorical variable *cut* are "fair", "good", "very good", "ideal", and "premium". We can look at how many diamonds are in each category. 

```{r, message = FALSE}
diamonds %>%
  group_by(cut) %>%
  summarise(count = n())
```

The table shows the number of diamonds of each cut. We call this a *distribution table*. A distribution shows all the values of a variable, along with the frequency of each one.

### Bar Chart

The bar chart is a familiar way of visualizing categorical distributions. It displays a bar for each category. The bars are equally spaced and equally wide. The length of each bar is proportional to the frequency of the corresponding category.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = diamonds, mapping = aes(x = cut)) + 
  geom_bar()
```

The y-axis displays *cut*, a variable from `diamonds`. However, the x-axis displays *count*, a variable not from `diamonds`. How is this possible? 

Line geoms and point geoms simply plot the raw values given from the dataset. Bar geoms, however, calculate *new* values to plot, like a *count*. The algorithm used to compute the new values is called a statistical transformation, or __stat__. It works as follows.

```{r, echo=FALSE, fig.align="center", fig.asp=1/2, fig.cap="Figure courtesy of *R for Data Science*, Grolemund and Wickham"}
knitr::include_graphics('images/visualization-stat-bar.png')
```

To summarize: `ggplot2` transforms the raw table to a new dataset of categories with its corresponding counts. From this new table, the bar plot is constructed by mapping `cut` to the x-axis and `count` to the y-axis. 

The default stat used is `stat_count()`, which counts the number of cases at each `x` position. If the counts are already present in the dataset and we would prefer to instead use these directly  for the heights of the bars, we can set `stat = "identity"`. For instance, consider this table about popular pies sold at a bakery. The "count" is already present in the `sold` variable. 

```{r, fig.align="center", dpi=80, warning = FALSE}
store_pies <- tribble(
  ~pie,             ~sold,
  "Pecan",            906,
  "Key Lime",         620,
  "Pumpkin",          202,
  "Apple",            408,
  "Mississippi mud",  551
)
ggplot(data = store_pies) +
  geom_bar(mapping = aes(x = pie, y = sold), stat = "identity")
```

Note how both `x` and `y` aesthetics must be provided when using the `identity` stat. 

### Towards numerical variables 

Let's turn to the `happy` data frame. We can consider the *categories* to be points on the 10-point scale, and the *individuals* the students in each interval. Let's determine this distribution table. 

```{r out.width = "50%", fig.align="default", message = FALSE}
happy_students <- group_by(happy, happy) %>% 
  summarise(count = n())
happy_students
```
We can now use this table, along with the graphing skills that we acquired above, to draw a bar chart that shows which scores are most frequent among the 39 students.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = reorder(happy, -count), y = count), stat = "identity") +
  xlab("Happy score")
```

There is something unsettling about this chart. Though it does answer the question of which "happy" scores appear most frequently among the students, it doesn't list the scores in chronological order. It is treating `happy` as a categorical variable.

But the scores are fixed chronological units that do have an order. Let's see what happens when we try to take that into account. In the `ggplot2` code written above, `reorder()` was used to sort the categories (scores) from highest to lowest. Let's run the code again without sorting by count.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = happy, y = count), stat = "identity") +
  xlab("Happy score")
```

Now the scores are in increasing order. We can attempt an answer to our second question: is there an association between feelings of belonginess and "happy" scores? Put another way, what relationship, if any, exists between `love` and `happy`? 

### More on positional adjustments

With point geoms we saw the usefulness of the "jitter" position adjustment to overcome the problem of overplotting. Bar geoms similarly benefit from positional adjustments. For instance, we can set the `color` or `fill` of a bar plot.

```{r eval = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

To make this code work, note how the parameter passed to the `color` and `fill` aesthetic is converted to a factor, or categorical variable, via `as.factor()`. As discussed, the `happy` variable is *numerical*. However, `ggplot2` can only color or fill a bar chart based on a categorical variable.    

Something interesting happens when the fill aesthetic is mapped to another variable other than `happy`, e.g., `love`.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)))
```

This visualization produces a "stacked" bar chart! Each bar is a composite of both `happy` and `love`. It also reveals something else that is interesting: feelings of belonginess are associated with higher marks on the "happy" scale. While we must maintain caution about making any causative statements at this point, this visualization demonstrates that bar charts can be a useful aid when exploring a dataset for possible relationships.

The stacking is performed by the position adjustment specified by the `position` argument. Observe how the bar chart changes with these other options: 

* `position = "fill"` makes each bar the same height. This way we can compare proportions across groups. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "fill")
```

* `position = "dodge"` places the stacked bars directly *beside* one another. This makes it easier to compare individual values. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "dodge")
```

Bar charts are intended as visualizations of categorical variables. When the variable is numerical, the numerical relations between its values have to be taken into account when we create visualizations. That is the topic of the next section. Before ending the discussion here, we turn to one more important piece of `ggplot2` magic.  

### Coordinate Systems 

We noted earlier that one of the three motifs of any `ggplot2` plot is its coordinate system. In all of the `ggplot2` code we have seen so far, there has been no explicit mention as to the coordinate system to use. Why? If no coordinate system is specified, `ggplot2` will default to using the Cartesian (i.e., horizontal and vertical) coordinate system. In Cartesian coordinates, the `x` and `y` coordinates are used to define the location of every point in the dataset, as we have just seen. 

This is not the only coordinate system offered by `ggplot2`, and learning about other coordinate systems that are available can help boost the overall quality of a visualization.

* `coord_flip()` flips the `x` and `y` axes. For instance, this can be useful when the x-axis labels on a bar chart overlap each other.  

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip()
```


* `coord_polar()` uses polar coordinates. It is useful for plotting a Coxcomb chart. Note the connection between this and a bar chart.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_polar()
```

* `coord_cartesian(xlim, ylim)` can be passed arguments for "zooming in" the plot. For instance, we may want to limit the height of very tall bars (and, similarly, the effect of very small bars) in a bar chart by passing in a range of possible y-values to `ylim`.   

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip() +
  coord_cartesian(ylim=c(1,10))
```

This can also be a neat trick for eliminating the (awkward) gap between the bars and the x-axis :-)

## Visualizing Numerical Distributions 

Many of the variables that data scientists study are *quantitative* or *numerical*. Their values are numbers on which you can perform arithmetic. Examples that we have seen include the number of periods in chapters of a book, the amount of money made by movies, and the age of people in the United States.

The values of a categorical variable can be given numerical codes, but that doesn't make the variable quantitative. In the example in which we studied MBA student data broken down by marks on a "happiness" scale, the categorical variable `love` had the numerical codes 1 for "lonely," 2 for "secure relationship," and 3 for "feelings of belonging and caring". While 1, 2, and 3 are numbers, in this context it doesn't make sense to subtract 1 from 2, or take the average of 1, 2, and 3, or perform other arithmetic on the three values. `love` is a categorical variable even though the values have been given a numerical code.

For our main example, we will return to a dataset we studied when we were learning scatter and line plots. It is the table `mpg`, which consists of data on fuel efficiency of popular car models. Use `?mpg` for a description of the dataset. 

### Visualizing the Distribution of `hwy`

In this section we will draw graphs of the distribution of the numerical variable in the column `hwy`, which describes miles per gallon of car models on the highway. For simplicity, let's create a subset of the table that includes only the information we need. We'll show a snapshot of this table by sampling 10 random rows from it.  

```{r}
mpg_sub <- select(mpg, manufacturer, model, hwy)
slice_sample(mpg_sub, n = 10)
```

### A Histogram 

A *histogram* of a numerical dataset looks very much like a bar chart, though it has some important differences that we will examine in this section. First, let's just draw a histogram of the highway miles per gallon.

The geom histogram generates a histogram of the values in a column. Note how the `y` aesthetic is mapped to a computed variable `..density..` (we will see what is being computed in just a moment). The histogram below shows the distribution of `hwy`. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg_sub, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..))
```

### The Horizontal Axis 

The amounts have been grouped into contiguous intervals called bins. The histogram geom has an endpoint convention: bins include the data at their right endpoint, but not the data at their left endpoint. We will use the notation (a, b] for the bin that starts at a and ends at b but doesn't include a. Sometimes, adjustments have to be made in the first or last bin, to ensure that the smallest and largest values of the variable are included. 

We can see that there are about 30 bins (bars with no height are hard to distinguish), and that they all have the same width. We can also see that no car models had less than 10 highway miles per gallon. 

It is a little harder to see exactly where the ends of the bins are situated. For example, it is not easy to pinpoint exactly where the value 22 lies on the horizontal axis. So it is hard to judge exactly where one bar ends and the next begins.

The optional argument `breaks` can be used with the histogram geom to specify the endpoints of the bins. It must consist of a sequence of numbers that starts with the left end of the first bin and ends with the right end of the last bin, which is provided by the function `seq()`.  We will start by setting the numbers in bins to be 10, 11, 12, and so on, ending with 50.

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,1)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "gray", breaks = bins)
```

The tallest bar contains car models with `hwy` equal to 26. A small number of cars have `hwy ` greater than 30.  

### The Counts in the Bins 

The counts of values in the bins can be computed from a data frame using `cut()`, which takes a column of data and the bin boundaries. The result is a tabular form of a histogram. It lists the right endpoints of the bins (but see the note about the final value, below) and the counts of all values in the hwy column that are in the corresponding bin. That is, it counts all the hwy values that are greater than or equal to the value in bin, but less than the next value in bin.

```{r}
binned <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins)) %>%
  count(bin, .drop = FALSE) %>%
  print(n = Inf)
```

Notice the bin value 10 in the first row. That's not the right end-point of any bar – it's the left end point of the first bar. By the endpoint convention, the data there are not included. So the corresponding count is recorded as 0, and would have been recorded as 0 even if there had been cars with `hwy` less than 10. When either the histogram geom or `cut()` is called with a breaks argument, the graph only considers values that are in the specified bins. Once values have been binned, the resulting counts can be used by `ggplot2` to generate a histogram.  

### The Vertical Axis: Density Scale 

The horizontal axis of a histogram is straightforward to read, once we have taken care of details like the ends of the bins. The features of the vertical axis require a little more attention. We will go over them one by one.

Let's start by examining how to calculate the numbers on the vertical axis. If the calculation seems a little strange, have patience – the rest of the section will explain the reasoning.

__Calculation.__ The height of each bar is the percent of elements that fall into the corresponding bin, relative to the width of the bin.

```{r}
binned %>%
  mutate(percents = n / nrow(mpg_sub) * 100, 
         height = percents / 100) %>%
  print(n = Inf)
```

Go over the numbers on the vertical axis of the histogram above to check that the column `height` looks correct.

The calculations will become clear if we just examine the first row of the table.

Remember that there are 234 rows in the dataset. The (25, 26] bin contains 32 cars. That's 13.67% of all the cars: 

\[ Percent= \frac{32}{234} * 100 = 13.67 \]

The width of the (25, 26] bin is  $26 - 25 = 1$. So 

\[ Height = \frac{13.67}{100} = 0.1367 \]

The code for calculating the heights used the facts that there are 234 cars in all and that the width of each bin is 1.

This method of drawing histograms creates a vertical axis that is said to be *on the density scale*. The height of bar is __not__ the percent of entries in the bin; it is the percent of entries in the bin relative to the amount of space in the bin. That is why the height measures crowdedness or *density*.

Let's see why this matters.

### Unequal Bins

An advantage of the histogram over a bar chart is that a histogram can contain bins of unequal width. Below, the values in the `hwy` column are binned into three uneven categories.

```{r dpi=80,  fig.align="center", message = FALSE}
uneven_bins <- c(10, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey", 
                 breaks = uneven_bins, position = "identity")

```

Here are the counts in the three bins.

```{r}
mpg_sub %>%
  mutate(bin = cut(hwy, breaks = uneven_bins)) %>%
  count(bin, .drop = FALSE)
```

Although the ranges (10, 15] and (30, 45] have nearly identical counts, the bar over the former is twice as tall as the latter because it is only half as wide. The density of values in the (10, 15] is twice as much as the density in (30, 45].

Histograms help us visualize where on the number line the data are most concentrated, especially when the bins are uneven.

### The Problem with Simply Plotting Counts 

It is possible to display counts directly in a chart, by omitting the aesthetic mapping from `y` to `..density..`. The resulting chart has the same shape as a histogram when the bins all have equal widths, though the numbers on the vertical axis are different.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = bins, position = "identity")
```

While the count scale is perhaps more natural to interpret than the density scale, the chart becomes highly misleading when bins have different widths. Below, it appears (due to the count scale) that car models with high miles per gallon on the highway are more common than before, when in fact we have seen that they are relatively rare.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = uneven_bins, position = "identity")
```

Even though the geom used is a histogram, the figure above is __NOT A HISTOGRAM__. It misleadingly exaggerates the proportion of car models with `hwy` between 30 and 45 because the count of 10 to 15 is 17 and the count between 30 to 45 is 22. However, in the graph, the area of 10 to 15 is almost one-third of 30 to 45, which does not align with the true proportion. The height of each bar is simply plotted at the number of car models in the bin, without accounting for the difference in the widths of the bins.

The picture becomes even more absurd if the last two bins are combined.

```{r dpi=80,  fig.align="center", message = FALSE}
very_uneven_bins <- c(10, 15, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = very_uneven_bins, position = "identity")
```

In this count-based figure, the shape of the distribution of highway mileage per gallon is lost entirely.

### The Histogram: General Principles and Calculation 

The figure above shows that what the eye perceives as "big" is area, not just height. This observation becomes particularly important when the bins have different widths.
That is why a histogram has two defining properties:

1. The bins are drawn to scale and are contiguous (though some might be empty), because the values on the horizontal axis are numerical.

2. The __area__ of each bar is proportional to the number of entries in the bin.

Property 2 is the key to drawing a histogram, and is usually achieved as follows:

\[ \text{area of bar} = \text{percent of entries in bin} \]

The calculation of the heights just uses the fact that the bar is a rectangle:

\[ \text{area of bar} = \text{height of bar} × \text{width of bin} \]

and so

\[ \text{height of bar} = 
    \frac{\text{area of bar}}{\text{width of bin}} = 
    \frac{\text{percent of entries in bin}}{\text{width of bin}} \]

The units of height are "percent per unit on the horizontal axis."

When drawn using this method, the histogram is said to be drawn on the density scale. On this scale:

* The area of each bar is equal to the percent of data values that are in the corresponding bin.

* The total area of all the bars in the histogram is 100%. Speaking in terms of proportions, we say that the areas of all the bars in a histogram "sum to 1".


### Flat Tops and the Level of Detail 

Even though the density scale correctly represents percents using area, some detail is lost by grouping values into bins.

Take another look at the (10, 15] bin in the figure below. The flat top of the bar, at the density level 0.0145, hides the fact that the highway mileage is somewhat unevenly distributed across that bin.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), 
                 color = "grey",breaks = uneven_bins, position = "identity")
```

To see this, let us split the (10, 15] bin into 4 narrower bins, each of width 1.

```{r dpi=80,  fig.align="center", message = FALSE}
tiny_bins <- c(10, 11, 12, 13, 14, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey",
                 breaks = tiny_bins, position = "identity")
```

Some of the skinny bars are taller than 0.0145 and others are shorter; (10, 11] and  (12, 13] have heights of 0 because there is no data in these intervals. By putting a flat top at the level 0.0145 across the whole bin, we are deciding to ignore the finer detail and are using the flat level as a rough approximation. Often, though not always, this is sufficient for understanding the general shape of the distribution.

__The height as a rough approximation.__ This observation gives us a different way of thinking about the height. Look again at the (10, 15] bin in the earlier histograms. As we have seen, the bin is 5 hwy wide and contains 7.3% of the data. Therefore the height of the corresponding bar is at density level 0.0145.

Now think of the bin as consisting of 5 narrow bins that are each 1 wide. The bar's height of 0.0145 means that as a rough approximation, 1.45% of car models are in each of those 5 skinny bins of width 1 highway mile per gallon. 

Notice that because we have the entire dataset that is being used to draw the histograms, we can draw the histograms to as fine a level of detail as the data and our patience will allow. However, if you are looking at a histogram in a book or on a website, and you don't have access to the underlying dataset, then it becomes important to have a clear understanding of the "rough approximation" created by the flat tops.

### Histograms Q&A

Let's draw the histogram again, this time with four bins, and check our understanding of the concepts.

```{r dpi=80,  fig.align="center", message = FALSE}
some_new_bins <- c(10, 15, 23, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey",
                 breaks = some_new_bins, position = "identity")
```

```{r}
mpg_sub %>%
  mutate(bin = cut(hwy, breaks = some_new_bins)) %>%
  count(bin, .drop = FALSE) 
```

Look again at the histogram, and compare the (15, 23] bin with the (23, 45] bin.

__Q__: Which has more car models in it?

__A__: The (23, 45] bin. It has 129 cars, compared with 88 cars in the (15, 23] bin.

__Q__: Then why is the (23, 45] bar shorter than the (15, 23] bar?

__A__: Because height represents density per unit of space in the bin, not the number of car models in the bin. The (23, 45] bin does have more car models than the (15, 23] bin, but it is also a whole lot wider. So it is less crowded. The density of car models in it is much lower.

### Differences Between Bar Charts and Histograms 

* Bar charts display one quantity per category. They are often used to display the distributions of categorical variables. Histograms display the distributions of quantitative variables.

* All the bars in a bar chart have the same width, and there is an equal amount of space between consecutive bars. The bars of a histogram can have different widths, and they are contiguous.

* The lengths (or heights, if the bars are drawn vertically) of the bars in a bar chart are proportional to the value for each category. The heights of bars in a histogram measure densities; the areas of bars in a histogram are proportional to the numbers of entries in the bins.


