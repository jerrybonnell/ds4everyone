---
output:
  pdf_document: default
  html_document: default
---
# Tables

In the previous chapter, we studied the `stringr` package, which is part of
`tidyverse`. In this chapter, we introduce some other packages from `tidyverse`.
Since calling up `tidyverse` automatically calls up the packages it  contains,
there is no need for you to memorize where those packages come from and call up
the individual packages as you need to use them.
Data scientists often refer to the importance of data cleaning, stating that
without data cleaning no data analysis results are meaningful. Some are even
bolder to say that the most important process in data science is data cleaning
because from their point of view, the analysis process after data cleaning is a
routine to a great degree.

## Data Formats

The data sets that data scientists handle are quite often *rectangular* tables.
In a rectangular table, the rows have an identical number of cells and the columns have an identical number of cells, thus allowing accessing any cell by specifying a row and a column together. A conventional structure of a rectangular data in R is as follows:

* The rows represent individual objects, whose information is available in the data set.
* The columns represent individual properties, about which the data set provides information for each object. We often call the properties *attributes* as well as *variables*.
* The columns have unique names. We call then *attribute names* and *variable names*. If the names are unique, we use "attributes" and "variables" for "attribute names" and "variable names",
respectively.
* The rows may have unique names. If they do, either there is an attribute specifically for the names or the table offers the row names as additional information.


### Data Sets Readily Available in `tidyverse`

The `tidyverse` package comes with scores of data sets.

```{r}
library(tidyverse)
```

By typing `data()` you can see a list of data sets available in the RStudio environment you are in. If you do not call up `tidyverse` the list is probably short. For each data set you see on the list, you can inquire for some details, if there is any information available. To see the information, you type the name of the data set with a single question mark in front of it.

The Motor Trend Car Road Test data set `mtcars` is one data set available through `tidyverse`.

```{r}
?mtcars
```

Now let us load the data set by executing a simple assignment.
We call the data set by the name `myc`.

```{r}
myc <- mtcars
```


You can check the contents of `myc` by typing its name.

```{r}
myc
```

*Data frame* is a term R uses to refer to data formats like the `mtcars` data set.
In its simplest form, a data frame consists of single-dimensional vectors where each vector has a name.
This data set has row names.
We learn of the existence of row names when we see that R prints the data without a column name for the row names.

You can access an individual attribute (other than the row name information, which is not an attribute) by attaching the dollar sign to the name of the data frame and then the attribute name.
For example, by typing `myc$cyl`, you get the entire sequence for the column `cyl`.
Alternatively, if you know the position of the attribute in the data set, you can attach a pair square brackets with a comma and the position to get to the vector.
The `cyl` is at position 2 of the data, so the following two produces the same results.

```{r}
myc$cyl
myc[,2]
```   

How do you access a row of the data set?
Since the data set has row names, we can use a row name to access a row.
The syntax is different from the one for column access, though.
We use the square brackets instead of the dollar sign and inside the brackets place the row name and a comma.

Let us see what appear as the row names of the data set.
You can use `row.names(DATA_SET_NAME)` to obtain the listing of the row names.

```{r}
row.names(myc)
```

Let us grab the row for "Datsun 710".

```{r}
myc["Datsun 710",]
```
Since the row is the third one, we can use `[3,]` instead.

```{r}
myc[3,]
```

How do we know how many rows and columns in the data as well as the names of the attributes?
The following functions, `nrow`, `ncol`, and `colnames` answer those questions, respectively.

```{r}
nrow(myc)
ncol(myc)
colnames(myc)
```
In summary, to access the columns and the rows, here are the rules we should follow:

* We use a pair `DATA_SET_NAME[X,Y]` to access a cell at row position `X` and column position `Y`, where `DATA_SET_NAME` is the name of the data set and `X` and `Y` are positive integers.
* If we omit the X-part, like `DATA_SET_NAME[,Y]`, the expression specifies the entire column at position `Y`. If `S` is the name of the column, we can use an alternate expression `DATA_SET_NAME$S`.
* If we omit the Y-part, like `DATA_SET_NAME[X,]`, the expression specifies the entire row at position `X`. If the data set has row names and `W` is the name of the row at position `X` (that is, it must be a string), we can substitute the index with the name as in `DATA_SET_NAME[W,]`.




### Examining the Rows, Columns, Cells, and Row Names

You can use the function `unique` to obtain the unique values.
We find that there are three possibilities 4, 6, and 8.

```{r}
unique(myc$cyl)
```

We already know how to inquire about the maximum, minimum, etc. for a vector.
Let us check out the `mpg` attribute (which is Miles Per Gallon) in terms of the maximum, the minimum, and the listing in the increasing order.

```{r}
max(myc$mpg)
min(myc$mpg)
sort(myc$mpg)
```

```{r}
filter(myc,mpg == 33.9)
```

The function comes from a `tidyverse` package `dplyr`.
We will study `dplyr` next.

### Building a data set from its components.

Before moving on to `dplyr`, let us see how you can create a data set.
Suppose you have tests scores in Chemistry and Spanish for four people, Gail, Henry, Irwin, and Joan.
You can create three vectors, `names`, `Chemistry`, and `Spanish` each represening the names, the scores in Chemistry, and the scores in Spanish, and then assemble them into a data file using the function `data.frame`.
The `data.frame` takes a series of columns as arguments.
The columns appear in the data set as you specify them in the arguments.
You can specify the names of the rows using an optional argument `row.names=`.


```{r}
names <- c("Gail", "Henry", "Irwin", "Joan")
Chemistry <- c( 99, 98, 80, 92 )
Spanish <- c(87, 85, 90, 88)
ddd <- data.frame(Chemistry, Spanish, row.names = names)
```

Let us see how we can access the data on the tiny data set `ddd`.

```{r}
ddd$Chemistry
ddd$Spanish
row.names(ddd)
ddd["Henry",]
```

__Write-in Data Set__

The package `dplyr` brings some useful methods for creating data sets.
The first method allows you to create a data set manually.
You can use `dplyr` to write out the attributes and then data rows as they should appear in the table. For example, in the following:

```{r}
tribble(~Name,~English,~Mathematics,
               "Johnny",100,90,
               "Katy",90,100,
               "Lauren",89,94,
               "Manuel",95,79,
               "Nancy",80,80)
```

__Systematic Creation__

The package `tibble` brings a way for mechanical generation.

```{r}
tibble(x=1:10, y=x*x, z = 1.5*x - 0.2)
```
The `seq` that is native of R allows you to create a sequence.
The syntax is `seq(START,END,GAP)`, where the sequence starts from `START` and then adds `GAP` to the sequence until the value exceeds `END`.
We can create the sequence with the name "x", and then add three other columns based on the value of "x".

```{r}
tibble(x = seq(1,10,0.5), y = sin(x), z = cos(x), w = x^3 - 10*x^2 + x - 2)
```
__Rotating Data__

Sometimes we want to switch from the row-major view to the column-major by rotating the data.
The rotation is very simple. You have only to use the function `t()`.

```{r}
t(ddd)
```


__Creating a Row Name Attribute from Row Names or Row Index__

Row names and row indexes are out of reach using the attachment of the dollar sign and the attribute name.
The reason is that row names or indexes are not attributes.
To be able to process data using row indexes or row names, it is conveninent to be able to have a matching attribute.
A great benefit of `tibble` is you have functions to accomplish this.

Let us go back to the `mtcars` data set.
We have loaded it to the variable `myc` earlier.
Let us do that again.
We convert the row names to an attribute using the function `rownames_to_column(DATA,NEW_NAME)`.
In the syntax, `DATA` is the data set and `NEW_NAME` is the name of the attribute of the row names.
The function produces a new data set, and so let us capture it in a new data set, `myc2`.

Let us do this and examine the head of the original and the new version.

```{r}
myc <- mtcars
myc2 <- rownames_to_column(myc,"name")
head(myc)
head(myc2)
```


__Reading Data from an External Source__

Usually data scientists need to load data from files.
The package `readr` of `tidyverse` offers ways for that.
Let us start with loading `tidyverse`.

```{r}
library(tidyverse)
```

With the package `readr` can you read from, among others, comma-separated files (CSV files) and tab-delimited files (TAB files).
To read files, we specify in a string the location of the file and then use the function for reading the file, `read_csv` if it is a CSV file and `read_tab` if it is a TAB file.
Here is an example of reading from a URL of a file available on the internet.

```{r}
path <- "https://data.bloomington.in.gov/dataset/117733fb-31cb-480a-8b30-fbf425a690cd/resource/2b2a4280-964c-4845-b397-3105e227a1ae/download/pedestrian-and-bicyclist-counts.csv"
bloom <- read_csv(path)
```

The data set shows the traffic in the city of Bloomington, the hometown of the Indiana University at Bloomington, Indiana.
You can change the head part of the data by the function `head`.
The function call `head(DATA_SET_NAME)` produces some first rows of the data set `DATA_SET_NAME`.

```{r}
head(bloom)
```
Note that some attributes have space in them.
To access the column corresponding of the attribute, you cannot simply type of the attribute because of the white space.
You need to put the names in a matching pair of quotes (single quotation marks, double quotes, and backward single quotation marks will do).

```{r}
bloom$"N College and RR"
```


__Saving Data__

Saving a data file is easy.
You use `write_csv(DATA_NAME,PATH)` where `DATA_NAME` is the name of the data frame to save and `PATH` is the "path name" of the file.
Below, the action is to store the data frame `bloom` as "data/bloom.csv"; that is the folder in which R is running R has a folder "data" and the target of saving is "bloom.csv" in the folder. 

```{r}
write_csv(bloom, "data/bloom.csv")
```



## Data Preparation with `dplyr`

As we mentioned earlier, preprocessing data is such an important aspect of data science that some experts dare to say that the step is the most important step,
`dplyr` is a collection of useful functions for manipulating the data.
The package `dplyr` offers five important functions for data manipulation plus some miscellaneous ones.

* `mutate()` and `rename()`: for adding new attributes from existing attributes and for renaming rows
* `select()`: for selecting or deselecting attributes
* `filter()` and `slice()`: for selecting rows with criteria or by row numbers
* `arrange()`: for reordering rows.
* `group_by()` and `summarise()`: for grouping rows and summarizing them into single rows

```{r}
library(tidyverse)
```

Let us load `mtcars` as before and call it `myc`, and then as before, convert the row names to a real attribute.
Call the new attribute "make_model".

```{r}
myc <- mtcars
myc2 <- rownames_to_column(myc,"make_model")
```

__The function `mutate()`__

The function `mutate` creates a new attribute using the values of existing attributes.
The syntax for `mutate` is

* `mutate(DATA_SET_NAME, NEW_NAME = EXPRESSION, OPTION)`

where the `NEW_NAME = EXPRESSION` specifies the name of the new attribute and how to compute it, and `OPTION` is an option to specify the location of the new attribute relative to the existing attributes.
The position option is either of the form `.before=NUMBER` or of the form `.after=NUMBER` with `NUMBER` specifying the position of the column insertion and `.before` and `.after` specifying the insertion is before and after of the column  at position `NUMBER`, respectively.
The `EXPRESSION` can be either a mathematical expression or a function call.
Here is one example, where the new attribute is `which_make`.
We derive the value of "make" from the value of `make_model` by taking the first word from `make model.
The insertion position is before the second attribute, `mpg`.
To execute the replacement, we use `str_replace` by matching the pattern `" .*"` (one white space and then any character sequence) with `""`.
Note how we use the attribute name `make_model` in the expression.
We told you earlier that string operations are applicable to individual strings or string vectors.

The expression follows that rule.

```{r}
myc3 <- mutate(myc2, which_make = str_replace(make_model, " .*", ""), .before=2)
```

The function adds the new column to the original `myc2` tentatively and returns the resultant data set.
The original stays the same, as we see below.

```{r}
head(myc3)
```

```{r}
head(myc2)
```

How many different values appear in the `which_make` attribute?
We can use `unique` for removing duplicates to find out.
We can even apply `sort` to the result that `unique` produces to make the list have its elements in the alphabetical order.

```{r}
sort(unique(myc3$which_make))
```


When we need to create multiple new attributes, we can repeat the above process as many times as we create new columns.
That would be a little cumbersome because we do not need the intermediate products.
Conveniently there is the concept of "piping" with which you can pass data from one function to another.
The way to use piping is simple.

* You start by stating the initial database.
* For each operation to form, you append `%>%` and then the operation, where you omit the data-set-name part.
* If you need to save the result in a data set, you add `%-> THE_FINAL_NAME%` at the end.

Here is a way to execute `mutate` twice on `myc2` where the first one is the same as before and the second one is for adding a new attribute representing the product of `mpg` and `disp`.
We capture the resulting output in `myc4`.

```{r}
myc2 %>% mutate(which_make = str_replace(make_model, " .*", ""), .before=2) %>% mutate(mpg_disp = mpg * disp, .after=2) -> myc4
```

The expression in the above has only two `mutate` calls.
If you get to add more operations, the expression can ge very long.
To make the expression easier to parse, you can think of folding it by entering the return key to make it easier to read.
You enter expressions line by line in R, and so you should be mindful of where to break lines.
If the expression looks complete, the R environment executes what you've entered.
Typically, we end a line with a directive like `%>%` and `%->%` so the environment understands that the line is incomplete.



```{r}
myc2 %>%
  mutate(which_make = str_replace(make_model, " .*", ""), .before=2) %>%
  mutate(mpg_disp = mpg * disp, .after=2) ->
  myc4
```
__The function `rename()`__

The function allows you to rename a specific attribute.
The syntax is `NEW_NAME = OLD_NAME`.
Below, we replace the name `wt` with `weight` amd `cyl` with `cylinder`.

```{r}
myc2 %>% rename(weight = wt, cylinder = cyl)
```


__The function `select()`__

The selection of attributes occurs when you want to focus on a subset of the attributes of a data set at hand.
The function `select()` allows the selection in multiple possible ways.

In the simplest form of `select()`, we list the attributes we wish to include in the data with a comma in between.


```{r}
myc4 %>% select(make_model,which_make,mpg,cyl)
```
The listing can take `|` to mean "or", `&` to mean "and", and `!` to mean "not".
To simplify a complex specification, `select` allows `c(...)` for a list.
It also takes attribute matching options like `starts_with()`, `ends_with()`, and `contains()`, 
The example below demonstrates the use of some of these.
The criterion for selection is: in addition to`mpg` and `cyl`, any attribute whose name starts with some character other than "m" and contains "a" somewhere.


```{r}
myc4 %>% select(mpg,cyl | !starts_with("m") & contains("a"))
```
Another selection expression is `matches(EXP)` where `EXP` is a regular expression.
Recall that `^` and `$` are the start and end of a string, respectively, and `[a-z]{3,5}` means any lowercase alphabet sequence having length between 3 and 5.
The regular expression below thus means any "lowercase name having length between 3 and 5".

```{r}
myc4 %>% select(matches("^[a-z]{3,5}$"))
```



__Handling Missing Values__

The filtering function is useful when data has holes, which R presents as NA meaning "not available".
You can create a vector containing any number of NA.
Below, the data set has four columns and six rows, in which NA appears in row 6.

```{r}
na_data <- tibble( name = c("Donny", "Ely", "Freddie", "Gaby", "Huey", "Ivy"), A = c(1, 2, 3, 4, 5, NA), B = c(100, 90, 80, 90, 70, NA), C = c(99, 89, 85, 70, 65, 67))
na_data
```

If you need to get rid of all rows with NA, you can use `drop_na` which is part of `dplyr` (and thus, of tidyverse`).

```{r}
na_data %>% drop_na() -> na_data2
na_data2
```

Alternatively, you can use `replace_na` to give an instruction how to handle NA appearing in specific columns.
The syntax for the instruction is simple.
For each attribute you make a placement, state its name, add an equal sign, and then add the value you want to use for replacement.
The replacement instructions must appear in a list, even if there is only one replacement instruction.

Below, we place any NA in "A" with 0, in "B" with 77, and in "C" with 66.
You may state an instruction for an attribute with no occurrences of NA.

```{r}
na_data %>% replace_na(list(A = 0, B = 77, C = 66))
```

__The function `filter()`__

The function `filter` allows you to select rows using criteria.
The syntax is to put an expression for the inclusion criterion.
Below, we select only those rows whose value for "B" is less than or equal to 90.
The filter function by default, removes all rows for which evaluating the criteria is not possible due to NA.

```{r}
na_data %>% filter(B <= 90)
```

If you have multiple criteria you want to apply conjunctively (meaning all of them have to be true), you can connect the individual criteria with a comma in between.

```{r}
na_data %>% filter(B <= 90, B >= 80)
```

The filtering function has something clever, you can compute some values on the fly using some attributes and feed them into the filtering criterion.
Recall that `min` computes the minimum among the values in a vector.
You can use the function to compute the minimum in "B" ignoring the NA in the attribute.
The filtering function below takes the minimum and then keeps only those rows whose "B" value is less than or equal to the minimum.

```{r}
na_data %>% filter(C <= min(B, na.rm = TRUE))
```

__The function `arrange()`__

The function `arrange` allows you to reorder rows.
To arrange rows, you state a list of attributes in the order you want to use in arranging.
For each attribute you want to reder in the descending order, you put the attribute name in `desc`.
Below, we arrange data in the increasing order of `cyl` and then for each group of rows having a common `cyl` value, arrange them in the descending order of `mpg`.


```{r}
myc2 %>% arrange(cyl,desc(mpg))
```


__The function `slice()`__

The function is for selecting rows by specifying the rows position.
You can specify one row with its row number, a range of rows with a number pair `A:B` where you can you an expression involving `n()` to specify the number of rows in the data.
The following use of `slice()` uses the range `(n()-10):(n()-2)` is the range starting from the tenth line above the last line and ending at the second line above the last line.


```{r}
myc2 %>% slice((n()-10):(n()-2))
```

YOu can use `slice_head(n = NUMBER)` and `slice_tail(n = NUMBER)` to select the top `NUMBER` rows and the last `NUMBER` rows, respectively.

```{r}
myc2 %>% slice_head(n = 10)
myc2 %>% slice_tail(n = 11)
```


__The functions `group_by()` and `summarize()`__

These functions come handy when you want to examine data by grouping rows and obtaining some summary numbers within each group.
The syntax for `group_by` is simple. You list the attributes with which you want to build groups.
The syntax for `summarize()` is to add `SUMMARY = EXP` where t`SUMMARY` is the name of the summary column and `EXP` is the expression for the summary.
The example below uses `gear` and `cyl` for grouping, computes the averages of `mpg` and `disp`, and saves it in `myc4`.


```{r}
mtcars %>% rownames_to_column("make_model") %>%
  group_by(gear,cyl) %>% summarize(avgmpg = mean(mpg), avgdisp = mean(disp)) -> myc4
```

## Adding More Attribute

You can combine two data frames using a common attribute as the key for combining; that is, finding values in appearing in both data frames and then connecting rows have the names in common.
In general, if there multiple matches between the two data frames concerning the attribute, each possible row matches will appear.
The general syntax is `JOIN_METHOD_NAME(DATA1, DATA2, by="NAME")`.
Here `DATA1' and `DATA2` are the names of the data frames and `NAME` is the name of the key attributes.
There are four join functions.
The differences among them are in how they treat non-matching values.

* `left_join`: Exclude any rows in `DATA2` with no matching values in `DATA1`.
* `right_join`; Exclude any rows in `DATA1` with no matching values in `DATA2`.
* `inner_join`: Exclude any rows in `DATA2` and `DATA1` with no matching values in the other data frame.
* `full_join`: No exclusions.

The example below shows the results of four join operations.

```{r}
testA <- tibble( name = c("Adriana", "Beth", "Candy", "Emily"), Chem110 = c(90, 80, 95, 87), Spa101 = c(99, 50, 70, 78))
testB <- tibble( name = c("Adriana", "Beth", "Candy", "Florence"), MTH161 = c(80, 88, 93, 88), Bio110 = c(91, 61, 73, 83))
testA
testB
```

```{r}
ljoined = left_join(testA, testB, by="name")
ljoined
rjoined = right_join(testA, testB, by="name")
rjoined
ijoined = inner_join(testA, testB, by = "name")
ijoined
fjoined = full_join(testA, testB, by="name")
fjoined
```

You can stack up rows using `bind_rows`.

```{r}
testC <- tibble( name = c("Gail", "Helen", "Iman", "Jackie"), Chem110 = c(87, 88, 90, 79), Spa101 = c(77, 74, 94, 84))
bind_rows(testA, testC)
```



