---
output:
  pdf_document: default
  html_document: default
---
# Data Frames

In the previous chapter, we studied the `stringr` package, which is part of `tidyverse`.
In this chapter, we go over more packages from `tidyverse`.
There is no need for you to memorize where those packages come from and call up the individual packages as you need to use them.
Data scientists often refer to the importance of data cleaning, stating that without data cleaning no data analysis results are meaningful.
Some are even bolder to say that the most important process in data science is data cleaning because from their point of view, the analysis process after data cleaning is a routine to a great degree.

## Data Formats

The data sets that data scientists handle are quite often *rectangular* tables.
In a rectangular table, the rows have an identical number of cells and the columns have an identical number of cells, thus allowing accessing any cell by specifying a row and a column together.
A conventional structure of a rectangular data in R is as follows:

* The rows represent individual objects, whose information is available in the data set. We often call them *observations*.
* The columns represent properties of the observations. We often call the properties *attributes* as well as *variables*.
* The columns have unique names. We call then *attribute names* and *variable names*. If the names are unique, we use *attributes* and *variables* for attribute names and variable names, respectively.
* The rows may have unique names. If they do, either there is an attribute specifically for the names or the table offers the row names as additional information.


### Data Sets Readily Available in `tidyverse`

The `tidyverse` package comes with scores of data sets.

```{r}
library(tidyverse)
```

By typing `data()` you can see a list of data sets available in the RStudio environment you are in.
Quite a few data come with `tidyverse`.
If your session has not yet loaded `tidyverse`, the list can be short.

For each data set you see on the list, you can inquire for some details, if there is any information available.
To see the information, you type the name of the data set with a single question mark in front of it.

The _Motor Trend Car Road Test_ data set `mtcars` is one data set available through `tidyverse`.

```{r}
?mtcars
```

Let us load the data set by executing a simple assignment.
We call the data set by the name `myc`.
We accomplish the naming with an assignment.

```{r}
myc <- mtcars
```

You can check the contents of `myc` by typing its name.

```{r}
myc
```

The designation `<dbl>` appearing indicates that the column has only double values.
The leftmost column in the table does not have the column header or the type designation.
The strings appearing in the column are the row names.

*Data frame* is a term R uses to refer to data formats like the `mtcars` data set.
In its simplest form, a data frame consists of single-dimensional vectors where each vector has a name.
This data set has row names.
We learn of the existence of row names when we see that R prints the data without a column name for the row names.

You can access an individual attribute (other than the row name information, which is not an attribute) by attaching the dollar sign to the name of the data frame and then the attribute name.
For example, by typing `myc$cyl`, you get the entire sequence for the column `cyl`.
Alternatively, if you know the position of the attribute in the data set, you can attach a pair square brackets with a comma and the position to get to the vector.
The `cyl` is at position 2 of the data, so the following two produces the same results.

```{r}
myc$cyl
myc[,2]
```   

How do you access a row of the data set?
Since the data set has row names, we can use a row name to access a row.
The syntax is different from the one for column access, though.
We use the square brackets instead of the dollar sign and inside the brackets place the row name and a comma.

Let us see what appear as the row names of the data set.
You can use `row.names(DATA_SET_NAME)` to obtain the listing of the row names.

```{r}
row.names(myc)
```

Let us grab the row for "Datsun 710".

```{r}
myc["Datsun 710",]
```
Since the row is the third one, we can use `[3,]` instead.

```{r}
myc[3,]
```

How do we know how many rows and columns in the data as well as the names of the attributes?
The following functions, `nrow`, `ncol`, and `colnames` answer those questions, respectively.

```{r}
nrow(myc)
ncol(myc)
colnames(myc)
```

In summary, to access the columns and the rows, here are the rules we should follow:

* We use a pair `DATA_SET_NAME[X,Y]` to access a cell at row position `X` and column position `Y`, where `DATA_SET_NAME` is the name of the data set and `X` and `Y` are positive integers.
* If we omit the X-part, like `DATA_SET_NAME[,Y]`, the expression specifies the entire column at position `Y`. If `S` is the name of the column, we can use an alternate expression `DATA_SET_NAME$S`.
* If we omit the Y-part, like `DATA_SET_NAME[X,]`, the expression specifies the entire row at position `X`. If the data set has row names and `W` is the name of the row at position `X` (that is, it must be a string), we can substitute the index with the name as in `DATA_SET_NAME[W,]`.




### Examining the Rows, Columns, Cells, and Row Names

You can use the function `unique` to obtain the unique values.
We find that there are three possibilities 4, 6, and 8.

```{r}
unique(myc$cyl)
```

We already know how to inquire about the maximum, minimum, and other properties of a vector.
Let us check out the `mpg` attribute (which is Miles Per Gallon) in terms of the maximum, the minimum, and the listing in the increasing order.

```{r}
max(myc$mpg)
min(myc$mpg)
sort(myc$mpg)
```

```{r}
filter(myc,mpg == 33.9)
```

The function comes from a `tidyverse` package `dplyr`.
We will study `dplyr` later in this chapter.



### Building a data set from its components.

Before moving on to `dplyr`, let us see how you can create a data set.
The package `tibble` offers some useful tools when you are creating a data.

Suppose you have tests scores in Chemistry and Spanish for four people, Gail, Henry, Irwin, and Joan.
You can create three vectors, `names`, `Chemistry`, and `Spanish` each representing the names, the scores in Chemistry, and the scores in Spanish, and then assemble them into a data file using the function `data.frame`.
The `data.frame` takes a series of columns as arguments.
The columns appear in the data set as you specify them in the arguments.
You can specify the names of the rows using an optional argument `row.names=`.

Below, we show a small experiment with the database idea we have just described.
We create two data sets, `ddd` and `dddX`.
The former does not have the row name column specification, and the latter does not.


```{r}
names <- c("Gail", "Henry", "Irwin", "Joan")
Chemistry <- c( 99, 98, 80, 92 )
Spanish <- c(87, 85, 90, 88)
ddd <- data.frame(names, Chemistry, Spanish)
dddX <- data.frame(Chemistry, Spanish, row.names = names)
ddd
dddX
```
Notice the difference between the two appears in the handling of the "names" list.
In the former, the names, "Gail", "Henry", "Irwin", and "Joan", appear as elements of the column with column name "names".
The data type designation `<chr>` means "character" and so indicates that the column consists of strings.
In the latter, the column lacks the name and type specification, and so represents the row names. 

Let us see how we can access the data on the tiny data set `ddd`.

```{r}
ddd$Chemistry
ddd$Spanish
row.names(ddd)
ddd["Henry",]
```




__Write-in Data Set__

The package `dplyr` brings some useful methods for creating data sets.
The first method allows you to create a data set manually.
You can use `dplyr` to write out the attributes and then data rows as they should appear in the table. For example, in the following:

```{r}
tribble(~Name,~English,~Mathematics,
               "Johnny",100,90,
               "Katy",90,100,
               "Lauren",89,94,
               "Manuel",95,79,
               "Nancy",80,80)
```

__Systematic Creation__

The package `tibble` brings a way for mechanical generation.

```{r}
tibble(x=1:10, y=x*x, z = 1.5*x - 0.2)
```

The `seq` that is native of R allows you to create a sequence.
The syntax is `seq(START,END,GAP)`, where the sequence starts from `START` and then adds `GAP` to the sequence until the value exceeds `END`.
We can create the sequence with the name "x", and then add three other columns based on the value of "x".

```{r}
tibble(x = seq(1,10,0.5), y = sin(x), z = cos(x), w = x^3 - 10*x^2 + x - 2)
```


__Rotating Data__

Sometimes we want to switch from the row-major view to the column-major by rotating the data.
The rotation is very simple. You have only to use the function `t()`.
Simply applying `t()` does not complete the task of transposition.
Below, we rotate the `mtcars` data set.

```{r}
t(mtcars)
```


It is imperative that the data you are rotating has row names.
Let us take the following example of data we construct with `tribble`

```{r}
ddd <- tribble(~Name,~English,~Mathematics,
               "Johnny",100,90,
               "Katy",90,100,
               "Lauren",89,94,
               "Manuel",95,79,
               "Nancy",80,80)
ddd
```

The data does not have row names.
The student names are the values of the attribute "Name".
If we rotate the data using `t`, we get the following.

```{r}
dddT <- t(ddd)
dddT
```

The three columns of `ddd` become rows and the rows of `ddd` appear as columns `[,1]` through `[,5]`.
These are merely column index specifications.
We can tell R to handle `dddT` as a data frame.

```{r}
ddd1 <- t(ddd)
dddT <- as.data.frame(ddd1)
dddT
```
The `[,`]` etc. now are now column names "V1" etc., but we still have "Name" as a row.
We thus must turn "Name" as a column name and _then_ rotate.
In the following, we process `ddd` with column conversion of "Name" to row names, then apply `t`.
Voila!

```{r}
ddd1 <- column_to_rownames(ddd, "Name")
dddT <- t(ddd1)
dddT
```

__Creating a Row Name Attribute from Row Names or Row Index__

Row names and row indexes are out of reach using the attachment of the dollar sign and the attribute name.
The reason is that row names or indexes are not attributes.
To be able to process data using row indexes or row names, it is convenient to be able to have a matching attribute.
A great benefit of `tibble` is you have functions to accomplish this.

Let us go back to the `mtcars` data set.
We have loaded it to the variable `myc` earlier.
Let us do that again.
We convert the row names to an attribute using the function `rownames_to_column(DATA,NEW_NAME)`.
In the syntax, `DATA` is the data set and `NEW_NAME` is the name of the attribute of the row names.
The function produces a new data set, and so let us capture it in a new data set, `myc2`.

Let us do this and examine the head of the original and the new version.

```{r}
myc <- mtcars
myc2 <- rownames_to_column(myc,"name")
head(myc)
head(myc2)
```

___Moving Columns___

When you want to change the order of columns by moving a column from the present location to another.
We can relocate a column using the `relocate` function by specifying which column should go where.
The syntax is `relocate(DATA_NAME,ATTRIBUTE,NEW_LOCATION)`.
The specification for the new location is either by `.before=NAME` or by `.after=NAME`, where `NAME` is the name of a column.

```{r}
ddd %>% relocate(Name, .after=Mathematics)
```

__Reading Data from an External Source__

Usually data scientists need to load data from files.
The package `readr` of `tidyverse` offers ways for that.
Let us start with loading `tidyverse`.

```{r}
library(tidyverse)
```

With the package `readr` can you read from, among others, comma-separated files (CSV files) and tab-delimited files (TAB files).
To read files, we specify in a string the location of the file and then use the function for reading the file, `read_csv` if it is a CSV file and `read_tab` if it is a TAB file.
Here is an example of reading from a URL of a file available on the internet.

```{r}
path <- "https://data.bloomington.in.gov/dataset/117733fb-31cb-480a-8b30-fbf425a690cd/resource/2b2a4280-964c-4845-b397-3105e227a1ae/download/pedestrian-and-bicyclist-counts.csv"
bloom <- read_csv(path)
```

The data set shows the traffic in the city of Bloomington, the hometown of the Indiana University at Bloomington, Indiana.
You can change the head part of the data by the function `head`.
The function call `head(DATA_SET_NAME)` produces some first rows of the data set `DATA_SET_NAME`.

```{r}
head(bloom)
```
Note that some attributes have space in them.
To access the column corresponding of the attribute, you cannot simply type of the attribute because of the white space.
You need to put the names in a matching pair of quotes (single quotation marks, double quotes, and backward single quotation marks will do).

```{r}
bloom$"N College and RR"
```

__Saving Data__

Saving a data file is easy.
You use `write_csv(DATA_NAME,PATH)` where `DATA_NAME` is the name of the data frame to save and `PATH` is the "path name" of the file.
Below, the action is to store the data frame `bloom` as "data/bloom.csv"; that is the folder in which R is running R has a folder "data" and the target of saving is "bloom.csv" in the folder. 

```{r}
write_csv(bloom, "data/bloom.csv")
```







## Data Preparation with `dplyr`

As we mentioned earlier, preprocessing data is such an important aspect of data science that some experts dare to say that the step is the most important step,
`dplyr` is a collection of useful functions for manipulating the data.
The package `dplyr` offers five important functions for data manipulation plus some miscellaneous ones.

* `mutate()` and `rename()`: for adding new attributes from existing attributes and for renaming rows
* `select()`: for selecting or deselecting attributes
* `filter()` and `slice()`: for selecting rows with criteria or by row numbers
* `arrange()`: for reordering rows.
* `group_by()` and `summarise()`: for grouping rows and summarizing them into single rows

```{r}
library(tidyverse)
```

Let us load `mtcars` as before and call it `myc`, and then as before, convert the row names to a real attribute.
Call the new attribute "make_model".

```{r}
myc <- mtcars
myc2 <- rownames_to_column(myc,"make_model")
```

__The function `mutate()`__

The function `mutate` creates a new attribute using the values of existing attributes.
The syntax for `mutate` is

* `mutate(DATA_SET_NAME, NEW_NAME = EXPRESSION, OPTION)`

where the `NEW_NAME = EXPRESSION` specifies the name of the new attribute and how to compute it, and `OPTION` is an option to specify the location of the new attribute relative to the existing attributes.
The position option is either of the form `.before=NUMBER` or of the form `.after=NUMBER` with `NUMBER` specifying the position of the column insertion and `.before` and `.after` specifying the insertion is before and after of the column  at position `NUMBER`, respectively.
The `EXPRESSION` can be either a mathematical expression or a function call.
Here is one example, where the new attribute is `which_make`.
We derive the value of "make" from the value of `make_model` by taking the first word from `make model.
The insertion position is before the second attribute, `mpg`.
To execute the replacement, we use `str_replace` by matching the pattern `" .*"` (one white space and then any character sequence) with `""`.
Note how we use the attribute name `make_model` in the expression.
We told you earlier that string operations are applicable to individual strings or string vectors.

The expression follows that rule.

```{r}
myc3 <- mutate(myc2, which_make = str_replace(make_model, " .*", ""), .before=2)
```

The function adds the new column to the original `myc2` tentatively and returns the resultant data set.
The original stays the same, as we see below.

```{r}
head(myc3)
```

```{r}
head(myc2)
```

How many different values appear in the `which_make` attribute?
We can use `unique` for removing duplicates to find out.
We can even apply `sort` to the result that `unique` produces to make the list have its elements in the alphabetical order.

```{r}
sort(unique(myc3$which_make))
```

When we need to create multiple new attributes, we can repeat the above process as many times as we create new columns.
That would be a little cumbersome because we do not need the intermediate products.
Conveniently there is the concept of "piping" with which you can pass data from one function to another.
The way to use piping is simple.

* You start by stating the initial database.
* For each operation to form, you append `%>%` and then the operation, where you omit the data-set-name part.
* If you need to save the result in a data set, you add `%-> THE_FINAL_NAME%` at the end.

Here is a way to execute `mutate` twice on `myc2` where the first one is the same as before and the second one is for adding a new attribute representing the product of `mpg` and `disp`.
We capture the resulting output in `myc4`.

```{r}
myc2 %>% mutate(which_make = str_replace(make_model, " .*", ""), .before=2) %>% mutate(mpg_disp = mpg * disp, .after=2) -> myc4
```

The expression in the above has only two `mutate` calls.
If you get to add more operations, the expression can ge very long.
To make the expression easier to parse, you can think of folding it by entering the return key to make it easier to read.
You enter expressions line by line in R, and so you should be mindful of where to break lines.
If the expression looks complete, the R environment executes what you've entered.
Typically, we end a line with a directive like `%>%` and `%->%` so the environment understands that the line is incomplete.

```{r}
myc2 %>%
  mutate(which_make = str_replace(make_model, " .*", ""), .before=2) %>%
  mutate(mpg_disp = mpg * disp, .after=2) ->
  myc4
```

It is possible to combine multiple `mutate` functions into one with a comma in between, but you can specify only one place for insertion.
Also, you can use the attribute name for the column position.

```{r}
myc2 %>%
  mutate(which_make = str_replace(make_model, " .*", ""), mpg_disp = mpg * disp, hp_per_wt = hp / wt, .after=make_model) ->
  myc4
myc4
```
Also, there is an option of which original attributes to keep after computing the new attributes.
The way to specify the keep choice is to use `.keep=OPTION` where `OPTION` is one of "all", "used", "unused", and "none", which mean all, only those you used in mutation, only those you did not use in mutation, and none, respectively.
The following mutation expression creates three new attributes, "which_make", "mpg_disp", and "hp_per_wt", put them after "make_model", and keep only those you used "make_model", "mpg", "disp", "hp" and "wt". 

```{r}
myc2 %>%
  mutate(which_make = str_replace(make_model, " .*", ""), mpg_disp = mpg * disp, hp_per_wt = hp / wt, .keep='used', .after = make_model) ->
  myc4
myc4
```
__The function `transmute()`__

The function `transmute()` is a variant of `mutate()` where you keep only new attributes you generate.

```{r}
myc2 %>% transmute(which_make = str_replace(make_model, " .*", ""), mpg_disp = mpg * disp, hp_per_wt = hp / wt)
```

__The function `rename()`__

The function allows you to rename a specific attribute.
The syntax is `NEW_NAME = OLD_NAME`.
Below, we replace the name `wt` with `weight` amd `cyl` with `cylinder`.

```{r}
myc2 %>% rename(weight = wt, cylinder = cyl)
```

__The function `select()`__

The selection of attributes occurs when you want to focus on a subset of the attributes of a data set at hand.
The function `select()` allows the selection in multiple possible ways.

In the simplest form of `select()`, we list the attributes we wish to include in the data with a comma in between.
Here is the same `myc4` we used.

```{r}
myc2 %>%
  mutate(which_make = str_replace(make_model, " .*", ""), mpg_disp = mpg * disp, hp_per_wt = hp / wt, .after=make_model) ->
  myc4
myc4
```
We select four from this data.

```{r}
myc4 %>% select(make_model,which_make,mpg,cyl)
```
The listing can take `|` to mean "or", `&` to mean "and", and `!` to mean "not".
To simplify a complex specification, `select` allows `c(...)` for a list.
It also takes attribute matching options like `starts_with()`, `ends_with()`, and `contains()`, 
The example below demonstrates the use of some of these.
The criterion for selection is: in addition to`mpg` and `cyl`, any attribute whose name starts with some character other than "m" and contains "a" somewhere.

```{r}
myc4 %>% select(mpg,cyl | !starts_with("m") & contains("a"))
```
Another selection expression is `matches(EXP)` where `EXP` is a regular expression.
Recall that `^` and `$` are the start and end of a string, respectively, and `[a-z]{3,5}` means any lowercase alphabet sequence having length between 3 and 5.
The regular expression below thus means any "lowercase name having length between 3 and 5".

```{r}
myc4 %>% select(matches("^[a-z]{3,5}$"))
```

__Handling Missing Values__

The filtering function is useful when data has holes, which R presents as NA meaning "not available".
You can create a vector containing any number of NA.
Below, the data set has four columns and six rows, in which NA appears in row 6.

```{r}
na_data <- tibble( name = c("Donny", "Ely", "Freddie", "Gaby", "Huey", "Ivy"), A = c(1, 2, 3, 4, 5, NA), B = c(100, 90, 80, 90, 70, NA), C = c(99, 89, 85, 70, 65, 67))
na_data
```

If you need to get rid of all rows with NA, you can use `drop_na` which is part of `dplyr` (and thus, of tidyverse`).

```{r}
na_data %>% drop_na() -> na_data2
na_data2
```

Alternatively, you can use `replace_na` to give an instruction how to handle NA appearing in specific columns.
The syntax for the instruction is simple.
For each attribute you make a placement, state its name, add an equal sign, and then add the value you want to use for replacement.
The replacement instructions must appear in a list, even if there is only one replacement instruction.

Below, we place any NA in "A" with 0, in "B" with 77, and in "C" with 66.
You may state an instruction for an attribute with no occurrences of NA.

```{r}
na_data %>% replace_na(list(A = 0, B = 77, C = 66))
```

There is a way to fill missing values by dragging the non-NA value immediately above an NA to its position.
In this manner, all NA's after the first non-NA will acquire a value.
This works when the top row does not have an NA.
In the case where the top row has an NA and the bottom row does not have an NA, you can drag the values upwards instead.
You can combine the two actions in a bidirectional manner, either going down and then up or going up and then down.
The directional specifications are: "up", "down", "updown", and "downup".
You can use the option `.direction = DIRECTION` with one of the four in place of `DIRECTION`.
The default direction is "down", and so you do not have state it.

In the example below, we create a data set of three attributes with many NA's.
The first column `name` has "James" in the top row and so you can fill downward to eliminate all the NA's.
The second column `math` is the opposite. The top row has an NA and the bottom does not.
You can fill upward.
The last column `soc` has an NA in the top row and an NA in the bottom row, and so a single-directional filling would leave out the top or the bottom NA.
We can fill using bidirectional replacement.
You can see the difference between when you use "down" and when you use "downup" for the third column.

```{r}
name = c("James", NA, NA, "Karol", NA, NA, "Lindsay", NA, NA)
math = c(NA, 8, NA, 7, 6, 5, 4, NA, 7)
soc = c(NA, 6, 7, 8, NA, NA, 9, 8, NA)
data0 <- tibble(name, math, soc)
data0
data0 %>% fill(name) %>% fill(math, .direction = "up") %>% fill(soc, .direction = "down")
data0 %>% fill(name) %>% fill(math, .direction = "up") %>% fill(soc, .direction = "downup")
```

If you want to make an across-the-board replacement of NA with a specific value, you can use `replace(is.na(.), X)`.
Here `X` is a value whose data type matches all the NA's.
In the case of `data0` in the above, "name" has strings and the other two have double values.
You thus cannot use replace the NA's across the board with a single value.
Rather, you need to split it into two steps, with the first step taking care of the NA's in "name" and then the second taking care of filling the remaining NA's with 0.


```{r}
data0 %>% fill("name") %>% replace(is.na(.), 0)
```


__The function `filter()`__

The function `filter` allows you to select rows using criteria.
The syntax is to put an expression for the inclusion criterion.
Below, we select only those rows whose value for "B" is less than or equal to 90.
The filter function by default, removes all rows for which evaluating the criteria is not possible due to NA.

```{r}
na_data %>% filter(B <= 90)
```

If you have multiple criteria you want to apply conjunctively (meaning all of them have to be true), you can connect the individual criteria with a comma in between.

```{r}
na_data %>% filter(B <= 90, B >= 80)
```

The filtering function has something clever, you can compute some values on the fly using some attributes and feed them into the filtering criterion.
Recall that `min` computes the minimum among the values in a vector.
You can use the function to compute the minimum in "B" ignoring the NA in the attribute.
The filtering function below takes the minimum and then keeps only those rows whose "B" value is less than or equal to the minimum.

```{r}
na_data %>% filter(C <= min(B, na.rm = TRUE))
```

__The function `arrange()`__

The function `arrange` allows you to reorder rows.
To arrange rows, you state a list of attributes in the order you want to use in arranging.
For each attribute you want to reder in the descending order, you put the attribute name in `desc`.
Below, we arrange data in the increasing order of `cyl` and then for each group of rows having a common `cyl` value, arrange them in the descending order of `mpg`.


```{r}
myc2 %>% arrange(cyl,desc(mpg))
```


__The function `slice()`__

The function is for selecting rows by specifying the rows position.
You can specify one row with its row number, a range of rows with a number pair `A:B` where you can you an expression involving `n()` to specify the number of rows in the data.
The following use of `slice()` uses the range `(n()-10):(n()-2)` is the range starting from the tenth line above the last line and ending at the second line above the last line.


```{r}
myc2 %>% slice((n()-10):(n()-2))
```

YOu can use `slice_head(n = NUMBER)` and `slice_tail(n = NUMBER)` to select the top `NUMBER` rows and the last `NUMBER` rows, respectively.

```{r}
myc2 %>% slice_head(n = 10)
myc2 %>% slice_tail(n = 11)
```


__The functions `group_by()` and `summarize()`__

These functions come handy when you want to examine data by grouping rows and obtaining some summary numbers within each group.
The syntax for `group_by` is simple. You list the attributes with which you want to build groups.
The syntax for `summarize()` is to add `SUMMARY = EXP` where t`SUMMARY` is the name of the summary column and `EXP` is the expression for the summary.
The example below uses `gear` and `cyl` for grouping, computes the averages of `mpg` and `disp`, and saves it in `myc4`.


```{r}
mtcars %>% rownames_to_column("make_model") %>%
  group_by(gear,cyl) %>% summarize(avgmpg = mean(mpg), avgdisp = mean(disp)) -> myc4
```

## Adding More Attribute

You can combine two data frames using a common attribute as the key for combining; that is, finding values in appearing in both data frames and then connecting rows have the names in common.
In general, if there multiple matches between the two data frames concerning the attribute, each possible row matches will appear.
The general syntax is `JOIN_METHOD_NAME(DATA1, DATA2, by="NAME")`.
Here `DATA1' and `DATA2` are the names of the data frames and `NAME` is the name of the key attributes.
There are four join functions.
The differences among them are in how they treat non-matching values.

* `left_join`: Exclude any rows in `DATA2` with no matching values in `DATA1`.
* `right_join`; Exclude any rows in `DATA1` with no matching values in `DATA2`.
* `inner_join`: Exclude any rows in `DATA2` and `DATA1` with no matching values in the other data frame.
* `full_join`: No exclusions.

The example below shows the results of four join operations.

```{r}
testA <- tibble( name = c("Adriana", "Beth", "Candy", "Emily"), Chem110 = c(90, 80, 95, 87), Spa101 = c(99, 50, 70, 78))
testB <- tibble( name = c("Adriana", "Beth", "Candy", "Florence"), MTH161 = c(80, 88, 93, 88), Bio110 = c(91, 61, 73, 83))
testA
testB
```

```{r}
ljoined = left_join(testA, testB, by="name")
ljoined
rjoined = right_join(testA, testB, by="name")
rjoined
ijoined = inner_join(testA, testB, by = "name")
ijoined
fjoined = full_join(testA, testB, by="name")
fjoined
```

You can stack up rows using `bind_rows`.

```{r}
testC <- tibble( name = c("Gail", "Helen", "Iman", "Jackie"), Chem110 = c(87, 88, 90, 79), Spa101 = c(77, 74, 94, 84))
bind_rows(testA, testC)
```

## Pivoting Tables

Sometimes you encounter a situation in which you need to incorporate attributes as rows.
Look at the following simple data set with four scores for three people.

```{r}
library(tidyverse)
```


```{r}
toyexam <- tibble( name = c("Robert", "Susan", "Teresa"), exam1 = c(10, 9, 8), exam2 = c(8, 7, 9), exam3 = c(9.5, 10, 8.2), final = c(7, 7.5, 6.5))
```

```{r}
toyexam
```

What if we want to find the relationship between individual exam scores and the final (we will see such explorations of relations in the next chapter on)?
To make such comparisons, it is convenient that the three exam scores appear in just one column pair, with one column representing which exam score it is and the other representing the score, like:

```{r}
tibble( name = c("Robert", "Robert", "Robert", "Susan", "Susan", "Susan", "Teresa", "Teresa", "Teresa"), final = c(7.0, 7.0, 7.0, 7.5, 7.5, 7.5, 6.5, 6.5, 6.5), exams = c("1", "2", "3", "1", "2", "3", "1", "2", "3"), score = c(10, 8, 9.5, 9, 7, 10.0, 8, 9, 8.2))
```

You can use `pivot_longer` to accomplish the task.
The syntax for `pivot_longer` is very complex, and so we do not go over it in detail.
The one below takes the `toyexam`, merges all the columns whose names start with "exam" (the `starts_with` from `stringr` does the job), creates the new column with name "exams" from the collection, designates the prefix "exam" in the column names for removable, and presents the corresponding values under the column "score".


```{r}
toyexam %>% pivot_longer(cols = starts_with("exam"), names_to = "exams", names_prefix = "exam", values_to = "score") -> toyexam_longer
toyexam_longer
```

In contrast with `pivot_longer`, `pivot_wider` does the action to reverse the `pivot_longer`.
The function `pivot_wider` grabs a pair of columns and spreads the pair into a series of columns.
One column of the pair serves as the source for the new column names after spreading.
For each value appearing in the source column, the function creates a new column by the name.
The value appearing opposite to the source value appears as the value for the column corresponding to the source.

Below, we create a new data frame from `toyexam_longer` using the pair ("names", "score").
To specify the selection, we use a pair of arguments `names_from = exams` and `values_from = score`.

```{r}
toyexam_longer %>% pivot_wider(names_from = exams, values_from = score)
```
Since the values appearing in the "exams" column are simply numbers, the resultant column names with spreading are those numbers. If we want to add a prefix to those numbers, we can specify the prefix with an argument `names_prefix = PREFIX`, where `PREFIX` is a string serving as the prefix.
In the example below, we use "EX" as the prefix.

```{r}
toyexam_longer %>% pivot_wider(names_from = exams, values_from = score, names_prefix = "EX")
```

### A Case Study

```{r}
library(tidyverse)
```

Here is a data ser representing various scores from a course in Computer Science.

```{r}
read_csv("data/csc_course.csv")
```

The "number" column shows q unique number of each student.
There are ten "labXX" attributes, eleven "hwXX" attributes, and three "qzXX" scores.
Suppose we want compute for each index between 1 and 10, the difference of the "hw" value at the index fomr the "lab" value at the previous, that is, `hw10 - lab10`, `hw09 - lab09`, and so.
We make the following plan.

* Read the data and substitute each NA with 0.
* Create a data subset consisting of "number" and the ten "lab" scores.
* Pivot using the "lab" scores, extract the two characters following the prefix "lab", attach them after "number" to create a temporary ID.
* Repeat the same concerning the homework scores.
* The temporary ID is common between the two data subsets. Unite the two data sets using the common ID.
* Using the "lab" and "hw" scores, compute the difference.
* From the new merged version, remove the temporary ID.

The code below has descriptions of each transformation.

```{r}
# Load data and replace all NA's with 0
# Save it as `csc0`
read_csv("data/csc_course.csv") %>%
  replace(is.na(.), 0) -> csc0
# Create a lab part `csc_lab` by:
# (a) selecting "number" and the ten lab scores,
# (b) pivoting the lab scores into an attribute pair (lab_index,lab_score)
#     while removing "lab" from the attribute names,
#     where selection of the columns for pivoting is by way of specifying all the columns other than "number",
# (c) creating a new attribute "temp_id" by connecting the value appearing in "number",
#     an underscore, and the value appearing in "lab_index"
csc0 %>% select(number, lab01:lab10) %>%
  pivot_longer(cols = !number, names_to = "lab_index", values_to = "lab_score", names_prefix="lab" ) %>%
  mutate(temp_id = str_c(number, "_", lab_index)) -> csc_lab
# Create a homework part `hw_lab` by:
# (a) selecting "number" and the first ten homework scores,
# (b) pivoting the homework scores into an attribute pair (hw_index,hw_score)
#     while removing "hw" from the attribute names,
#     where selection of the columns for pivoting is by way of specifying all the columns other than "number",
# (c) creating a new attribute "temp_id" by connecting the value appearing in "number",
#     an underscore, and the value appearing in "hw_index"
csc0 %>% select(number, hw01:hw10) %>%
  pivot_longer(cols = !number, names_to = "hw_index", values_to = "hw_score", names_prefix="hw" ) %>%
  mutate(temp_id = str_c(number, "_", hw_index)) -> csc_hw
# check the two sub parts
csc_lab
csc_hw
# Create a merger `csc_new` by:
# (a) call `full_join` using "temp_id" as the attribute for connecting
# (b) compute the difference as a new attribute "diff"
# (c) create a new attribute "index" whose values are identical to those of "lab_index"
# (d) select five columns "number", "index", "lab_socre", "hw_score", and "diff" in this order.
full_join(csc_lab, csc_hw, name = temp_id) %>% mutate(diff = hw_score - lab_score) %>%
  mutate(index = lab_index) %>%
  select(number,index,lab_score,hw_score,diff) -> csc_new
csc_new
```

## Writing Functions

We have used several times by now, the word "function".
Here are some basic rules about functions.

* _A function is a block of chord with a name that allows execution from other codes._ This mean that you can take any part of a working (i.e., all parentheses and brackets in the part have matching counterparts in the same part) and specify it to be a function.
* _If the function is active in the present run of R, each time a code call the function, the code of the function runs._ This means that R suspends the execution of the present code and processes the execution of the code of the function. When it finishes running the code of the function, it returns to the execution of the one it has suspended.
* _A function may take upon the role of computing a value._ You can design a function so that it uses a special function `return()` at the end so as to specify the value it has computed.
* _If a function has the role of returning a value, the call itself represents the value it computes._ So you store the value the function computes in a variable using an assignment.
* _A function may require some number of values to use in its calculation._ We call them *arguments*. When using a function that requires, the arguments must appear in the call.

### A Very Simple Function

Here is a very simple function, `one_Ten`, which prints the sequence of integers from 1 to 10.
The definition of the function takes the form `one_ten <- function() { ... }`.

```{r, error = TRUE}
one_ten <- function() { print(1:10) }
```
Here is what happens when you call the function.
```{r}
one_ten()
```
Note that the call stands alone, i.e., you can use it without anything else but its name and a pair of parentheses.
By replacing the code appearing inside the curly brackets, you can define a different function with the same name `one_ten()`.
Let us reverse the order in which the numbers appear,

```{r, error = TRUE}
one_ten <- function() { print(10:1) }
```
Here is what happens when you call the function.
```{r}
one_ten()
```

The new behavior of `one_tne()` substitues the old one, and you cannot replay the behavior of the previous version.

### Functions That Compute a Value

To make a function compute a value, you add a line `return(VALUE)` at the end of the code in the brackets.
The function `my_family()` returns a list of names for persons.
Remember the `c()` function?
The function creates a new list with 19 names and returns the list.

```{r}
my_family <- function() {
  return(c("Amy", "Billie", "Casey", "Debbie", "Eddie", "Freddie", "Gary",
           "Hary", "Ivy", "Jackie", "Lily", "Mikey", "Nellie", "Odie",
           "Paulie", "Quincy", "Ruby", "Stacey", "Tiffany"))
}
```

The call for the function produces the list that the function returns.


```{r}
a <- my_family()
a
```

Now whenever you need the 19-name list, you can either call the function or refer to the variable `a` that holds the list.

### Functions That Take Arguments

To write a function that takes arguments, you determine how many arguments you need and determine the names you want to use for the arguments during the execution of the code for the function.
The `functionn()` declaration now has the names of the arguments.
You put them in the order you want to use with a comma in between.
Below, we define a function for computing the maximum of two numbers with a feature that if both numbers are smaller than 0, the maximum is not the maximum of the two negative numbers, but 0.
Note that we use the pairwise maximum twice in the code:
first for computing the maximum between the two arguments `x` and `y`, and then computing the maximum between the maximum and 0.
In that manner, if the first maximum is negative, the function returns 0 instead.

```{r, error = TRUE}
max0 <- function(x, y) { return(max(0, max(x, y))) }
```

Here is the demonstration of how the function works.

```{r}
max0(-10, 2)
max0(-10, -13)
```


### Practical Examples


Recall the data set `mtcars`.
We introduce a function that returns the country of origin of a make.
We follow the previous procedure for migrating the row names to an attribute and taking the prefix of the row names to the `which_make` attribute.
There are 22 makes that appear in the attribute.
We get to it by applying the function `unique()` to the `which_make` attribute.
We create a 22-element list of the country of origin corresponding to the `make` list.
Now the `car_origin()` function takes a string representing a make, finds its position in the `makes` list using the `match` function, and then returns the element of the country of origin list at the position.


```{r}
library(tidyverse)
```

```{r}
myc <- mtcars
myc2 <- rownames_to_column(myc,"make_model")
myc3 <- mutate(myc2, which_make = str_replace(make_model, " .*", ""), .before=2)
makes <- unique(myc3$which_make)
makes
countries <- c("Japan", "Japan", "USA", "USA", "USA", "USA", "USA", "USA",
             "USA", "Italy", "Japan", "Japan", "USA", "USA", "USA", "USA",
             "France", "Italy", "USA", "Italy", "Italy", "Sweden")
countries[match("AMC",makes)]
```
```{r}
car_origin <- function(x) {
  return(countries[match(x,makes)])
}
car_origin("Toyota")
```

Now we can furnish the `myc3` data set by creating a new column `country` as the result of applying the function `car_origin()` to the attribute `which_make`.


```{r}
myc3 %>% mutate(country = car_origin(which_make), .after = 2) 
```
