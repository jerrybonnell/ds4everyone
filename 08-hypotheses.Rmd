---
output:
  html_document: default
  pdf_document: default
---

# Hypothesis Testing

In the previous chapters, we learned about randomness and sampling. Quite often, a data scientist receives some data and must make some assertion about it. There are typically two kinds of situations:

* She has one dataset and a model that the data should have followed. She needs to decide if it is likely that the dataset indeed follows the model?
* She has two datasets. She needs to decide if it is possible to explain the two datasets using a single model.

Here are examples of the two situations.

* A company making coins is testing the fairness of a coin. Using some machine, the company tosses the coin 10,000 times. They record the face that turns up. By examining the record of the 10,000 tosses, can you tell how likely it is that the coin is fair?
* Is the proportion of enrolled Asian American students at Harvard University disproportionately less than the pool of Harvard-admissible applicants? (*SFFA v. Harvard*)

For both situations, an important consideration to make is in terms of how to compare the differences and figuring out how a sample at hand was generated. 

## Testing a Model

Suppose 10,000 tosses of a coin generate the following counts for "Heads" and "Tails": 

```{r}
mystery_coin <- tibble(face = c("Heads", "Tails"),
                       face_counts = c(4953, 5047)) 
mystery_coin
```

By dividing each number by 10,000, we get the *proportion* of the occurrence of each face.

```{r}
mystery_coin <- mystery_coin |>
  mutate(face_prop = face_counts / 10000)
mystery_coin
```

We notice that the values are not exactly 0.5 (= $1/2$). How far away is that from what we know about the distribution of a fair coin?

We know that the probability of each face in a fair coin is $1/2$. By subtracting $1/2$ from each and obtaining the absolute difference values from them by removing any negative sign we have: 

```{r}
mystery_coin <- mystery_coin |>
  mutate(fair_prop = 1/2,
         abs_diff = abs(face_prop - fair_prop))
mystery_coin
```

We then compute the sum and take one half of this value.  

```{r}
mystery_coin |>
  summarize(tvd_value = sum(abs_diff) / 2)
```

The number found by following the above steps is called the *test statistic*. The test statistic is a statistic used to evaluate a hypothesis, i.e., whether a coin at hand is fair or not. When we compute the test statistic from the data given to us, we call this the *observed value of the test statistic*.  

There are many possible test statistics we could have tried for this problem. This one goes by a special name: the *total variation distance* (or, for short, TVD). The total variation distance serves as the measure for the difference between two distributions, namely, the difference between some given distribution (e.g., following the coin handed to us) and a sampling distribution (e.g., following a fair coin). 

Another possible, and perhaps straightforward, test statistic is to simply count the number of heads that appear in the sample. 

```{r}
observed_heads <- mystery_coin |> 
  filter(face == "Heads") |> 
  pull(face_counts)
observed_heads
```

Is 4953 heads *too small* to be due to chance? It is hard to tell without knowing the number of heads we get by chance.

We can conduct some simulation to obtain a sampling distribution of the number of heads produced by a fair coin. As mentioned earlier, the proportion that each face turns up is not constant, even for a fair coin. So, by simulating tosses of a fair coin, we must expect to see a range of the number of heads seen. 

### Prerequisites

Before starting, let us load the `tidyverse` as usual.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```


### The `rmultinom` function

We saw before that we can generate a sampling distribution by putting in place some sampling strategy. Perhaps the most straightforward is simple random sampling with replacement. This will be the approach we continue to make use of here, as well as throughout the rest of the text.  

We also learned about two different ways to sample with replacement. `sample` samples items from a *vector*, which we used when simulating the expected amount of grains a minister receives after some number of days. `slice_sample` functions identically, but instead samples from rows of a *data frame* or tibble. To generate a sampling distribution for this experiment, we could just use `sample` again. But there is a quicker way, using a function called `rmultinom`, which is tailored for sampling at random from *categorical distributions*. We introduce it here and will use it several times this chapter.

Here is how we can use it to generate a sampling distribution of 100 tosses of a fair coin.

```{r}
fair_coin <- c(1/2, 1/2)
sample_vector <- rmultinom(n = 1, size = 100, prob = fair_coin)
sample_vector
```

For generating a sampling distribution, we are more interested in the *proportion* of resulting heads and tails. Thus, we should divide by the number of tosses. Note how the probability of heads and tails is about equal. 

```{r}
sample_vector / 100
```

So we can just as easily simulate proportions instead of counts.

The classic interpretation of `rmultinom` is that you have some marbles to put into boxes of size `size`, each with some probability `prob`; the length of `prob` determines the number of boxes. The result shows the number of marbles that end up in each box. Thus, the function takes the following arguments:

* `size`, the total number of marbles that are put into the boxes. 
* `prob`, the distribution of the categories in the population, as a vector of proportions that add up to 1.
* `n`, the number of samples to draw from this distribution. We will typically leave this at 1 to make things easier to work with later on.  

It returns a vector containing the number of marbles in each category in a random sample of the given size taken from the population. Because this distribution is so special, statisticians have given it a name: the *multinomial distribution*. 

Let us see how we can use it to assess the model for 10,000 tosses of a coin.  

### A model for 10,000 coin tosses  

We can extend our coin toss example code to incorporate the `rmultinom` function: 

```{r}
sample_tibble <- tibble(
  face = c("Heads", "Tails"), 
  fair_probs = 1/2, 
  sample_counts = rmultinom(n = 1,
                          size = 10000,
                          prob = fair_probs))
sample_tibble
```

How many heads are in this sample?

```{r}
sample_heads <- sample_tibble |>
  filter(face == "Heads") |>
  pull(sample_counts)
sample_heads
```

We can use this to generate a sampling distribution for the number of heads produced by a fair coin. Let's wrap this up into a function we can call. This will produce one simulated test statistic under the assumption of a fair coin. 

```{r}
one_simulated_statistic <- function() {
  sample_tibble <- tibble(
    face = c("Heads", "Tails"), 
    fair_probs = 1/2, 
    sample_counts = rmultinom(n = 1,
                            size = 10000,  
                            prob = fair_probs))
  
  sample_heads <- sample_tibble |>
    filter(face == "Heads") |>
    pull(sample_counts)
  
  return(sample_heads)
}
```

Next, we create a vector `sample_stats` containing 1,000 simulated test statistics. As before, we will use `replicate` to do the work. 

```{r echo=FALSE}
set.seed(1)
```

```{r}
num_repetitions <- 1000
sample_stats  <- replicate(n = num_repetitions, one_simulated_statistic())
```

### Chance of the observed value of the test statistic occurring

To interpret the results of our simulation, we start by visualizing the results using a  histogram of the samples.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_stats)) +
  geom_histogram(aes(x = sample_stats, y = after_stat(density)), 
                 fill = "darkcyan", color = 'gray', bins=14)
```

Where does the observed value fall in this histogram? We can plot it easily. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_stats)) +
  geom_histogram(aes(x = sample_stats, y = after_stat(density)), 
                 fill = "darkcyan", color = 'gray', bins = 12) +
  geom_point(aes(x = observed_heads, y = 0), size = 3, color = "salmon") +
  labs(x = "Number of heads")
```


Let us look at the proportion of the elements in the vector `sample_stats` that are at least as small as the observed number of heads or more extreme, whose value we have stored in `observed_heads`. We simply count the elements matching the requirement and then divide the count by the length of the vector.

```{r}
sum(sample_stats <= observed_heads) / length(sample_stats)
```

The value we get is 0.19, or about 19%. We interpret this value as stating the *chance* the test statistic achieves a value, under the assumption of the model, *at least as extreme* as 4953 heads or less. We conclude that a fair coin would yield the observed test statistic value we found (or less) 19% of the time. This value, computed through simulation, is what we call a *p-value*.

To compute a *p-value*, we take the following steps:

1. Establish some model that is possibly describing a quantifiable phenomenon.
2. Run a simulation to obtain a histogram of the quantifiable phenomenon under the model.
3. Compare the observation and examine where in the histogram the observation stands.

More specifically, we estimate how far the observation is from the central portion of the histogram by splitting the histogram at the point of observation. As shown in the following figure, the portion less than or equal to the observation (in dark cyan) and the portion greater than or equal to the observation (in orange). Note that we can include the equality, when the sampled value equals the observed value, on either side. 

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
colors <- c(rep("salmon",4), rep("darkcyan",8))

ggplot(tibble(sample_stats)) +
  geom_histogram(aes(x = sample_stats, y = after_stat(density)), 
                 bins = 12, fill = colors, color = 'gray') +
  geom_point(aes(x = observed_heads, y = 0), size = 3, color = "red")
```

The more orange bars that are visible in the histogram, the higher the likelihood of the observation. Conversely, the less orange bars there are, the lower the likelihood of seeing such an observation. The area covered by the orange bars is formally called the "area in the tail." The area in the tail is designated a special name:  __the p-value__. 

When we compute a p-value, we have in mind two possible interpretations. We call them the *Null Hypothesis* and the *Alternative Hypothesis*.

* __Null Hypothesis (NH):__ The hypothesis we use to create the model for simulation. For example, we assume that the coin we have is a fair coin, about 50% equal chance to see either face. Any variation from what we expect is because of chance variation.
* __Alternative Hypothesis (AH):__ The opposite, or counterpart, of the Null Hypothesis. For example, the AH states that the coin is *biased* towards tails. The difference we observed is caused by something other than randomness. 

It is important that your null hypothesis acknowledges differences in the data. For example, if the null hypothesis states that a die is fair, why did you not get any `3`'s when rolling the die 6 times? 

We can provide one more definition of the p-value in the language of these hypotheses:

> The chance, under the *null hypothesis*, of getting a test statistic equal to the observed test statistic or more extreme in the direction of the *alternative hypothesis*.

## Case Study: Entering Harvard

Harvard University is one of the most prestigious universities in the United States. A recent lawsuit by [Students for Fair Admissions (SFFA)](https://studentsforfairadmissions.org/) led by Edward Blum against Harvard University alleges that Harvard has used soft racial quotas to keep the numbers of Asian-Americans low.

Put differently, the allegation claims that, from the pool of Harvard-admissible American applicants, Harvard uses a racial discriminatory score that allows the college to choose disproportionately less Asian-Americans. As of this writing, the lawsuit has been appealed and is to appear before the Supreme Court.

This section examines the "Harvard model" to assess, at a basic level, the claim put forward by the lawsuit.  

### Prerequisites

Before starting, let's load the `tidyverse` as usual.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### Students for Fair Admissions

Harvard University publishes [some statistics](https://college.harvard.edu/admissions/admissions-statistics) on the class of 2024.
According to the data, the proportions of the class for Whites, Blacks, Hispanics, Asians, and Others (International and Native Americans) are respectively 46.1%, 14.7%, 12.7%, 24.4%, and 2.1%.

We do not have the data of the students admissible to enter Harvard so, in lieu of this, we refer to student demographics enrolled in a four-year college.
According to [Chronicle of Higher Education](http://www.chronicle.com) 2020-2021 Almanac, the racial demographics of full-time students in 4-year private non-profit institutions -- Harvard is one of them -- in Fall 2018 are: 63.6% White, 11.5% Black, 12.3% Hispanic, 8.1% Asian, and 4.5% Other.

Let's compile this information into a tibble.

```{r}
class_props <- tribble(~Race, ~Harvard, ~Almanac,
                             "White", 46.1, 63.6, 
                             "Black", 14.7, 11.5,
                             "Hispanic", 12.7, 12.3,
                             "Asian", 24.4, 8.1,
                             "Other", 2.1, 4.5)
class_props
```

The distributions may look quite different from each other. Of course, the demographics from the Almanac includes students who did not apply to Harvard, those who might not have got into Harvard, those applied and did not get in, and international students. Moreover, the Almanac data covers all full-time students in 2018 but not students who entered college in 2020.

Notwithstanding these differences, let us conduct an experiment to see how the demographics from Harvard look different from those given by the Almanac in terms of a sampling distribution.

As we will be handling proportions, let us scale the numbers down (by dividing each element by 100) so that they are expressed as percentages.

```{r}
class_props <- class_props |> 
  mutate(Harvard = Harvard / 100,
         Almanac = Almanac / 100)
class_props
```

We will also write a function that computes the total variation distance (TVD) between two vectors.  

```{r}
compute_tvd <- function(x, y) {
  return(sum(abs(x - y)) / 2)
}
```

In this study, our observed value is the TVD between the distribution of students in the Harvard class and the Almanac. 

```{r}
harvard_diff <- class_props |>
  summarize(compute_tvd(Harvard, Almanac)) %>%
  pull()
harvard_diff
```

The Harvard class of 2024 has 2015 students. We can think of the process of sampling 2015 people to fill the "Harvard class" from those who "were attending" a four-year non-profit college in Fall 2018 and then examining their racial distribution. Of course, we cannot reach out to those individuals specifically, but we know the distribution of the entire population from which we want to sample. Therefore, we can simulate a large number of times what this "Harvard class" looks like and compare it with what we know about the actual Harvard class distribution, available in `harvard_diff`. 

Our sampling plan can be framed as a "boxes and marbles" problem, as we saw in the previous section. There are five "boxes" to choose from, where each corresponds to a race: White, Black, Hispanic, Asian, and Other. The goal is to place marbles (which correspond to students) in each of the boxes, where the probability of ending up in any of the boxes is given by the Almanac. 

This is an excellent fit for the `rmultinom` function. For example, here is one simulation of the proportion of races found in a "Harvard class." 

```{r}
sample_vector <- rmultinom(n=1, size=2015, 
                           prob = pull(class_props, Almanac)) / 2015
sample_vector
```

How far is our simulated class from the Almanac? We compute the TVD to find out. 

```{r}
class_props |>
  mutate(sample = sample_vector) |>
  summarize(compute_tvd(sample, Almanac)) %>%
  pull()
```

We wrap our work into a function.  

```{r}
one_simulated_class <- function(props) {
  props |>
    mutate(sample = rmultinom(n=1, size=2015, prob = Almanac) / 2015) |>
    summarize(compute_tvd(sample, Almanac)) |>
    pull()
}
```

Let us simulate what 10,000 classes could look like. This will be contained in a vector called `sample_class_tvds`. Also, as before, we will use `replicate` to do the work. 

```{r}
num_repetitions <- 10000
sample_class_tvds <- replicate(n = num_repetitions, 
                               one_simulated_class(class_props))
```

We can now visualize the result. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_class_tvds)) +
  geom_histogram(aes(x = sample_class_tvds, y = after_stat(density)), 
                 bins = 30, fill = "darkcyan", color = 'gray')
```

Where does the true Harvard class lie on this histogram? We can plot a point geom to find out. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_class_tvds)) +
  geom_histogram(aes(x = sample_class_tvds, y = after_stat(density)), 
                 bins = 70, fill = "darkcyan", color = 'gray') +
  geom_point(aes(x = harvard_diff, y = 0), size = 3, color = "salmon")
```

The orange dot shows the distance value of the Harvard value from the Almanac value. What we see is that the proportion of the races at Harvard is nothing like the national proportion.

### Proportion of Asian American students

The prior experiment looked at the proportion of all races. However, the claim given by the lawsuit is specifically about Harvard-admissible students who are Asian American. We can now address this by refining our model to include only Asian American students and non-Asian American students. 

```{r}
class_props_asian <- tribble(~Race, ~Harvard, ~Almanac,
                             "Asian", 24.4, 8.1,
                             "Other", 75.6, 91.9)
class_props_asian
```

As before, we transform the data to be in terms of proportions.

```{r}
class_props_asian <- class_props_asian |> 
  mutate(Harvard = Harvard / 100,
         Almanac = Almanac / 100)
class_props_asian
```

The proportion of Asian American in private non-profit 4-year colleges is just 8.1% while the race occupies 24.4% of the Harvard freshman class. Let's recompute our observed TVD value. 

```{r}
harvard_diff <- class_props_asian |>
  filter(Race == "Asian") |>
  summarize(abs(Harvard - Almanac)) |>
  pull()
harvard_diff
```

Note that we took a shortcut for computing the TVD here. When dealing with two categories, the TVD is equal to the distance between the two proportions in one of the categories. 

Re-running the simulation is easy. Note that instead of passing `class_props` as an argument to the function `one_simulated_class`, we pass the new tibble `class_props_asian`.

```{r}
num_repetitions <- 10000
sample_class_tvds <- replicate(n = num_repetitions, one_simulated_class(class_props_asian))
```

We again visualize the result. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_class_tvds)) +
  geom_histogram(aes(x = sample_class_tvds, y = after_stat(density)), 
                 binwidth=0.002, fill = "darkcyan", color = 'gray')
```

Where does the observed value fall in this histogram? 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_class_tvds)) +
  geom_histogram(aes(x = sample_class_tvds, y = after_stat(density)), 
                 binwidth=0.002, fill = "darkcyan", color = 'gray') +
  geom_point(aes(x = harvard_diff, y = 0), size = 3, color = "salmon")
```

We find that the result is the same; the Harvard proportion of Asian American students is not at all like the national value. We can state, with great confidence, that Harvard enrolls much more Asian students than the national average. 

__Important note:__ The reader should be cautioned not to accept these results as direct evidence against the suit's case. As noted at the outset of this section, we do not know the proportion of Harvard-admissible students and must instead rely on a national Almanac for reference. The base population of students can be very much different which is, in fact, something we anticipated.


## Significance Levels

So far we have evaluated models by comparing some observation to a prediction made by a model. For instance, we compared:

* Racial demographics at Harvard University with the national Almanac at four-year non-profit private colleges. 
* 10,000 tosses of an unknown coin at hand with a fair coin. 

Sometimes the observed value of the test statistic ends up in the "bulk" of the predictions; sometimes it ends up very far away. But how do we define what "close" or "far" is? And at what point does the observed value transition from being "close" to "far"? 

This section examines the *significance* of an observed value. To set up the discussion, we introduce another example still on the topic of academics: midterm scores in a hypothetical Computer Science course. 

### Prerequisites

Before starting, let's load the `tidyverse` as usual. We will also use a dataset from the `edsdata` package, so let us load this in as well.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(edsdata)
```

```{r message = FALSE, warning = FALSE, echo = FALSE}
set.seed(1)
```


### A midterm grumble? 

A hypothetical Computer Science course had 40 enrolled students and was divided into 3 lab sections. A Teaching Assistant (TA) leads each section. After a midterm exam was given, the students in one section noticed that their midterm scores were lower compared to students in the other two lab sections. They complained that their performance was due to the TA's teaching. The professor faced a dilemma: is it the case that the TA is at fault for poor teaching or are the students from that section more vocal about their grumbles following a exam?

If we were to fill that lab section with randomly selected students from the class, it is possible that their average midterm grade will look a lot like the score the grumbling students are unhappy about. It turns out that what we have stated here is a chance model that we can simulate. 

Let's have a look at the data from each student in the course. The following tibble `csc_labs` contains midterm and final scores, and the lab section the student is enrolled in. 

```{r message = FALSE, warning = FALSE}
csc_labs
```

We can use the dplyr verb `group_by` to examine the mean midterm grade as well as the number of students in each section. 

```{r message = FALSE}
lab_stats <- csc_labs |>
  group_by(section) |>
  summarize(midterm_avg = mean(midterm),
            count = n())
lab_stats
```

Indeed, it seems that the section H students fared the worst, albeit by a small margin, among the three sections. Our statistic then is the mean grade of students in the lab section. Thus, our observed statistic is the mean grade from section H, which is about 68.56.  

```{r}
observed_statistic <- lab_stats |>
  filter(section == "H") |>
  pull(midterm_avg)
observed_statistic
```

We formally state our null and alternative hypothesis. 

__Null Hypothesis:__ The mean midterm grades of students in lab section H looks like the mean grades of a "section H" that is generated by randomly sampling the same number of students from the class.  

__Alternative Hypothesis:__ The section H midterm grades are too low. 

To form a random sample, we will need to sample *without* replacement 9 students from the course to fill up the theoretical "lab section H".  

```{r}
random_sample <- csc_labs |>
  select(midterm) |>
  slice_sample(n = 9, replace = FALSE)
random_sample
```

We can look at the mean midterm score for this randomly sampled section. 

```{r}
random_sample |>
  summarize(mean(midterm)) |>
  pull()
```

Now that we know how to simulate one value, we can wrap this into a function. 

```{r}
one_simulated_mean <- function() {
  random_sample <- csc_labs |>
    select(midterm) |>
    slice_sample(n = 9, replace = FALSE)
  
  random_sample |>
    summarize(mean(midterm)) |>
    pull()
}
```

We will simulate the "section H lab" 10,000 times. Let us run the simulation! 

```{r}
num_repetitions <- 10000
sample_means <- replicate(n = num_repetitions, one_simulated_mean())
```

As before, we visualize the resulting distribution of grades.  

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), 
                 bins = 15, fill = "darkcyan", color = 'gray')
```

It seems that the grades cluster around 72. Where does the actual section H section lie? Recall that this value is available in the variable `observed_statistic`. We overlay a point geom to our above plot.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), 
                 bins = 15, fill = "darkcyan", color = 'gray') + 
  geom_point(aes(x = observed_statistic, y = 0), size = 3, color = "salmon")
```

It seems that the observed statistic is "close" to the center of randomly sampled scores. 

### Cut-off points

Let's sort the sample means generated. We will examine in particular the value at 10% and 5% from the bottom. We will first turn to the value at 10%. 

```{r}
sorted_samples <- sort(sample_means)
sorted_samples[length(sorted_samples)*0.1]
```

We plot our sampling histogram and overlay it with a vertical line at this value.

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), 
                 bins = 15, fill = "darkcyan", color = 'gray') +
  geom_vline(xintercept = sorted_samples[length(sorted_samples)*0.1], y = 0, 
             size = 2, color = "purple")
```

This means that 10% of our simulated mean statistics are equal to or less than 63. Put differently, the chance of a an average midterm score *lower* than 63 occurring, under the assumption of a TA teaching in good faith, is around 10%. 

The situation is not much different if we look at the value 5% from the bottom, which we find to be about 61. We redraw the situation in on our sampling histogram. 

```{r}
sorted_samples[length(sorted_samples)*0.05]
```

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), bins = 15,
                 fill = "darkcyan", color = 'gray') +
  geom_vline(xintercept = sorted_samples[length(sorted_samples)*0.05], 
             size = 2, color = "purple")
```

This time, the chance of obtaining a simulated mean midterm score *at least* as low as 61 is about 5%.   

We say that the threshold point 63 is at the 90% *significance level* and the threshold point 61 is at the 95% significance level.

### The significance level is an error probability

The last figure shows that, although rare, a lab section with a "TA teaching in good faith" can still produce mean midterm scores that are at least as low as 61. How often does that occur? The figure gives the answer for that as well: it does so with about 5% chance. 

Therefore, if the TA is *teaching in good faith* and our test uses a 95% significance level to decide whether or not the TA is guilty, then there is about a 5% chance that the test will wrongly conclude that the mean midterm scores are too low and, consequently, the TA is at fault. This example points to a general fact about significance levels: 

> If you use a $p$% significance level for the p-value, and the null hypothesis happens to be true, there is about a $1-p$% chance that the test will incorrectly conclude the alternative hypothesis. 

Statistical inferences, unlike logical inferences, can be wrong! But the power of statistics lies in its ability to *quantify* how often this error will occur. In fact, we can control the chance of wrongly convicting the TA by choosing a higher significance level. We could look at the 99% significance level or even the 99.9% and 99.99% levels; these are commonly referred to in the area of physics which rely on enormous evidence to prove something axiomatic. 

Here, too, are trade-offs. By minimizing the error of wrongly convicting a TA teaching in good faith, we increase the chance of another kind of error occurring: our test concluding nothing when in fact there is something unusual about the lab section's midterm grades.  

It is important to note that these cut-off points are convention only and do not have any strong theoretical backing. They were first established by the statistician Ronald Fisher in his seminal work [*Statistical Methods for Research Workers*](https://en.wikipedia.org/wiki/Statistical_Methods_for_Research_Workers). 

Therefore, declaring an observed statistic as being "too low" or "too high" is a judgment call. In any statistics-based research, you should always provide the observed test statistic and the p-value used in addition to giving your decision; this way your readers can decide for themselves whether or not the results are indeed significant. 

### The verdict: is the TA guilty? 

We can set a modest significance level at 95% for the course case study. Of course, judgment is needed if the decision resulting from this study will cause the TA to be reprimanded -- we may tend towards a much more conservative significance level to be fully convinced, even if this means increasing the chance of a "guilty TA" being let free. 

We overlay the observed statistic on the sampling histogram. As before, the orange bars show the 95% significance region.

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), bins = 15,
                 fill = "darkcyan", color = 'gray') +
  geom_vline(xintercept = sorted_samples[length(sorted_samples)*0.05], 
             size = 2, color = "purple") + 
  geom_point(aes(x = observed_statistic, y = 0), size = 3, color = "red")
```

We see that the point does not cross the vertical purple line. We can check numerically how much area "is in the tail". 

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
colors <- c(rep("salmon",8), rep("darkcyan",7))
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), bins = 15,
                 fill = colors, color = 'gray') +
  geom_point(aes(x = observed_statistic, y = 0), size = 3, color = "red")
```

```{r}
sum(sample_means <= observed_statistic) / num_repetitions
```

We conclude the TA's defense holds up pretty well: the average lab section H scores are not any different from those generated by chance. It would be prudent to check in with the TA to get their take on the story.   

### Choosing a test statistic

By this point, we have been introduced to a few different test statistics. A common challenge when developing a hypothesis test is to first define what a "good" test statistic is for the problem. 

Consider your alternative hypothesis and what evidence favors it over the null. If only "large values" or "small values" of the test statistic favor the alternative, then we recommend using the test statistic. For instance, in the midterm example, we considered only "small values" of the sample mean statistic to determine if the lab section H scores are "too low." In the Harvard admissions example, we considered "large values" of the TVD test statistic to determine if the TVD of the Harvard proportions is "too big" to have been generated by a model under the null hypothesis. 

Avoid choosing test statistics where "both big values and small values" favor the alternative. In this case, the area that supports the alternative includes both the left and right "tails". Consider the following sampling histogram of the test statistic and note the tails as indicated by the orange bars. 

```{r dpi=80, fig.align="center", echo = FALSE, message = FALSE}
colors <- c(rep("salmon",6), rep("darkcyan",5), rep("salmon",4))
ggplot(tibble(sample_means)) +
  geom_histogram(aes(x = sample_means, y = after_stat(density)), bins = 15,
                 fill = colors, color = 'gray') +
  guides(x = "none", y = "none") + 
  labs(x = "", y="")
```

We suggest modifying your test statistic so that the evidence favoring the alternative involves only one tail.  

Finally, we present a table with some common test statistics and when to use each. 

| Test statistic                                   | When to use?                                                                                                               |
|--------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| Total Variation Distance (TVD)                   | __Categorical data__; compare your sample with the distribution it was drawn from. `rmultinom`                             |
| Number of heads, difference in means        | __Numerical data__; direction matters, e.g., "too few heads" or "too many heads"                                          |
| Absolute difference, mean absolute difference | __Numerical data__; direction does not matter, only distance, e.g., "number of heads seen is different from a chance flip" |

## Permutation Testing

In the previous section, we study the use of hypothesis testing. In this section we learn a simple method to compare two distributions using a method we call *permutation testing*. This allows us to decide if the two distributions come from the same underlying distribution.

<!--
* We have two sets of numerical data A and B, which respectively have the mean values $a$ and $b$, with difference $d = a - b$.
* We want to know, assuming that the two datasets have the same origin, how large (or small) chances are that the difference of $d$ emerges when we redivide the join of A and B into two groups, only retaining the sizes of A and B.
* For each such random split, we compute the difference in the mean values.
* By repeating such random splits many times, we can obtain distributions of the means.
--> 

### Prerequisites

Let us begin by loading the `tidyverse`. We will also use a dataset from the `edsdata` package.

```{r message = FALSE, warning = FALSE}
library(tidyverse)
library(edsdata)
```

### The effect of a tutoring program 

The tibble `finals` from the `edsdata` package contains final exam grades in a hypothetical Computer Science course for 105 students. They are divided into two groups, based on two different offerings of the course labeled `A` and `B`. The more recent offering `B` featured a tutoring program for students to receive help on assignments and exams. The course instructor is interested in finding out if the tutoring program boosted overall performance in the class, measured by a final exam. This could help the instructor and department decide if the program should continue or even be expanded. Suppose that the dataset is collected over two semesters from the same Computer Science course.

Let's first load the dataset. 

```{r message = FALSE}
finals
```

We can examine the number of enrolled students in each of the two offerings. 

```{r}
finals |>
  group_by(class) |>
  count()
```

It appears they are about equal. Let's now turn to a distribution of the students in the offering that featured the tutoring program (class `B`) compared to those in the offering without the program (class `A`). To generate an overlaid histogram, we use the positional adjustment argument `identity` and set an `alpha` so that the bars are drawn with slight transparency. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(finals) + 
  geom_histogram(aes(x = grade, y = after_stat(density), fill = class),
                 bins = 10, color = "gray",
                 alpha = 0.7, position = "identity")
```

By observation alone, it seems that the final scores of students in the offering where the tutoring program was available (`B`) is slightly to the right of the distribution corresponding to scores when the program did not exist (`A`). Could this be chalked up to chance?

As we have done throughout this chapter, we can address this question by means of a hypothesis test. We will state a null and alternative hypothesis that arise from the problem. 

__Null hypothesis:__ In the population, the distribution of final exam scores where the  tutoring program was available is the same as those when the service did not exist. The difference seen in the sample is because of chance. 

__Alternative hypothesis:__ In the population, the distribution of final exam scores when the tutoring program was available are, on average, *higher* than the scores when the program was not.  

According to the alternative hypothesis, the average final score in offering `B` should be *higher* than the average final score in offering `A`. Therefore, a good test statistic we can use is the difference in the mean between the two groups. That is,

\[
\text{test statistic} = \mu_B - \mu_A
\]

where $\mu$ denotes the mean of the group. 

First, we form two vectors `finalsA` and `finalsB` that contain final scores with respect to the course offering. 

```{r}
finalsA <- finals |>
  filter(class == 'A') |> pull(grade)
finalsB <- finals |>
  filter(class == 'B') |> pull(grade)
```

The observed value of the statistic can be computed as the following. 

```{r}
observed_statistic <- mean(finalsB) - mean(finalsA)
observed_statistic
```

We can write a function that computes the statistic for us. We call it `mean_diff`. 

```{r}
mean_diff <- function(a, b) {
  return(mean(a) - mean(b))
}
```

Observe how it returns the same value for the observed statistic. 

```{r}
mean_diff(finalsB, finalsA)
```

To predict the statistic under the null hypothesis, we defer to an idea called the *permutation test*. 

### A permutation test 

Suppose that we are given the following vector of integers. 

```{r}
1:10
```

We can interpret these numbers as indices that refer to an element inside a vector. We imagine that the first half of indices belong to a group `A`, and the second half group `B`. 

Under the assumption of the null hypothesis, there should be no difference between the two distributions `A` and `B` with respect to the underlying population. For example, whether a final exam score belongs to the course offering `A` or `B` should have no effect on the mean final score. If so, there should be no consequences if we place both groups into a pot, shuffle them around, and compute the mean difference from the result. The resulting value we get from this process is one simulated value of the test statistic under the null hypothesis. 

The first bit of machinery we need is a function that shuffles a sequence of integers. We actually already know one: `sample`. 

```{r}
shuffled <- sample(1:10)
shuffled
```

In this example, `sample` receives a vector of numbers 1 through 10 and returns the result after shuffling them. We might also call the result a *permutation* of the original sequence -- hence, its namesake. 

If we again interpret the resulting vector as indices, we take the first half to be the indices of the shuffled group A and the second half the shuffled group B. 

```{r}
shuffled[1:5]  # shuffled group A
shuffled[6:10] # shuffled group B
```

The remaining work then is to compute the difference in means between the shuffled groups. 

The function `one_mean_difference` puts everything together. It receives two vectors, `a` and `b`, puts them together in a pot, and deals out two shuffled vectors with the same size as `a` and `b`, respectively. The function returns the value of the simulated statistic by calling the functional `compute_statistic`. For this example, we use `mean_diff`. 

```{r}
one_difference <- function(a, b, compute_statistic) {
  pot <- c(a, b)
  sample_indices <- sample(1 : length(pot))
  shuffled_a <- pot[sample_indices[1 : length(a)]]
  shuffled_b <- pot[sample_indices[(length(a) + 1) : length(pot)]]
  return(compute_statistic(shuffled_a, shuffled_b))
}
```

We are now ready to perform a permutation test for the tutoring program example. We would like to simulate the test statistic under the null hypothesis multiple times and collect the values into a vector. As before, we can use `replicate`. We will simulate 10,000 values. 

```{r}
differences <- replicate(n = 10000, 
                         one_difference(finalsA, finalsB, mean_diff))
```

### Conclusion

Let's visualize the results. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(tibble(differences)) + 
  geom_histogram(aes(x = differences, y = after_stat(density)), 
                 col="grey", fill = "darkcyan", bins = 20) +
  geom_point(aes(x = observed_statistic, y = 0), color = "salmon", size = 3)
```

First, observe how the distribution is centered around 0. Under the assumption of the null hypothesis, there is no difference between the final exam averages in the two course offerings and, therefore, the difference clusters around 0. 

Also observe that the observed test statistic is quite far from the center. To get a better sense of how far, we compute the p-value. 

```{r}
sum(differences >= observed_statistic) / 10000
```

This means that the chance of obtaining a mean difference at least as large as $6.10$ is around 8%. By standards of the conventional cut-off points we have discussed, we would have enough evidence to refute the null hypothesis at a 90% significance level. Would this be enough to convince us that the tutoring program is indeed effective? Let us consider for a moment what it would mean if it does not. 

If we were to demand a higher significance level, say 95%, our observed statistic is no longer significant. The logical next step would be to conclude that the null hypothesis is true, bearing the implication that the tutoring program is ineffective. This would be a statistical fallacy! Even if our results are not significant at the desired level, we do __NOT__ take the null hypothesis to be true. Put another way, __we fail to reject the null hypothesis__. That is a mouthful! 

The problem here is a lack of evidence. A lack of evidence does not prove that something *does not* exist, e.g., the tutoring program is *not* effective; it very well could be, but our study missed it. Indeed, our permutation test only evaluated one criteria -- that is, difference in final exam scores -- as a measure for improvement. There are other test statistics or criteria we could have considered, like class participation, which may have benefited from the program. It would be up to the judgment of the department on how to use these results in deciding the merit of the tutoring program. 

### Another permutation test: Summer and Winter Olympic athletes 

We end this section with one more example of a permutation test: comparing the weight information of Summer and Winter Olympic athletes. The dataset is available in the name `athletes` from the `edsdata` package.

For the sake of this analysis, we focus on Olympic games after the 2000 Summer Olympics. 

```{r message = FALSE}
my_athletes <- athletes |>
  filter(Year > 2000)
```

We can glance at how much athletes we have in each season. 

```{r}
my_athletes |>
  count(Season) %>%
  mutate(prop = n / sum(n))
```

We observe that Summer athletes make up the bulk of this dataset. Before proceeding any further, we should visualize the weight information with an overlaid histogram. 

```{r dpi=80, fig.align="center", message = FALSE}
my_athletes |>
  ggplot() + 
    geom_histogram(aes(x = Weight, y = after_stat(density), fill = Season),
                   bins = 13, color = "gray",
                   alpha = 0.7, position = "identity")
```

We give our hypothesis statements. 

__Null hypothesis:__ In the population, the distribution of weight information in the Summer Olympics is, on average, the same as the Winter Olympics. 

__Alternative hypothesis:__ In the population, the distribution of weight information in the Summer Olympics is, on average, different from the Winter Olympics. 

Note that the alternative hypothesis, unlike the tutoring program example, does not care whether the weight information for athletes competing in the Winter Olympics is *higher* or *less* than that of athletes in the Summer Olympics. It only states that some *difference* exists. Therefore, the absolute difference in the means would be a good test statistic to use for this problem.   

\[
\text{test statistic} = | \mu_B - \mu_A | 
\]

Note how it does not matter which group ends up as A and likewise for B. Let's write a function to compute this statistic; it is a slight variation of the `mean_diff` we saw before. 

```{r}
mean_abs_diff <- function(a, b) {
  return(abs(mean(a) - mean(b)))
}
```

### The test 

We form two vectors `winter_weights` and `summer_weights` that contain the weight information with respect to the season. 

```{r}
winter_weights <- my_athletes |> 
  filter(Season == "Winter") |> 
  pull(Weight)
summer_weights <- my_athletes |> 
  filter(Season == "Summer") |> 
  pull(Weight)
```

The observed value of the statistic can be computed as the following. 

```{r}
observed_statistic <- mean_abs_diff(winter_weights, summer_weights)
observed_statistic
```

We are now ready to perform the permutation test. As before, let us simulate the test statistic under the null hypothesis 10,000 times. 

```{r echo=FALSE}
set.seed(3)
```

```{r}
differences <- replicate(n = 10000, 
                one_difference(winter_weights, summer_weights, mean_abs_diff))
```

### Conclusion

We are ready to visualize the results. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(tibble(differences)) + 
  geom_histogram(aes(x = differences, y = after_stat(density)), 
                 col="grey", fill = "darkcyan", bins = 15) +
  geom_point(aes(x = observed_statistic, y = 0), color = "salmon", size = 3)
```

The observed statistic is quite far away from the distribution of simulated test statistics. Let's do a numerical check. 

```{r}
sum(differences >= observed_statistic) / 10000
```

The chance of obtaining a mean absolute difference of $1.29$ is roughly 0.1%. We can safely reject the null hypothesis at a significance level over 99%. This confirms that, assuming our dataset is representative of the population of Olympic athletes, the weight information between Summer and Winter Olympic players are likely, on average, to be different. 
