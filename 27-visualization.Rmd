# Visualization 

Tables are a powerful way of organizing and visualizing data. However, large tables of numbers can be difficult to interpret, no matter how organized they are. Sometimes it is much easier to interpret graphs than numbers.

## Visualizing with `ggplot2`

In this chapter we will develop some of the fundamental graphical methods of data analysis. Our source of data is the `mpg` dataset, which contains observations collected by the US Environmental Protection Agency on 38 models of car between 1999 and 2008. We visited this dataset briefly in Section \@ref(introtables), but we turn to it again to reveal interesting properties about it, made possible by visualization. 

R provides many facilities for creating visualizations, but `ggplot2` provides one of the most elegant and flexible ways of doing so. Moreover, `ggplot2` is based on a system called the *grammar of graphics*, and learning it will allow you to apply the tool to many visualization tasks. 

### Prerequisites

This chapter will make great use of `ggplot2`, which is also a component of the tidyverse. Loading in the tidyverse will also load in `ggplot2`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### The `mpg` data frame  

The table has 234 rows and 11 columns. Use `?mpg` open its help page. Let's have a look at a snapshot of the data again.  

```{r}
mpg
```

Another way to preview the data is by using `glimpse()`. 

```{r}
glimpse(mpg)
```

__Terminology.__ A *variable* is a formal name for what we have been calling a "feature", such as "highway miles per gallon." The term variable emphasizes that the feature can have different values for different individuals – the numbers of movies that actors have been in varies across all the actors.

Variables that have numerical values, such as 'highway miles per gallon' or 'engine displacement' are called *quantitative* or *numerical* variables.

### The layered grammar of graphics

The grammar of graphics states that every plot can be built from the same few components: (1) a __dataset__, (2) a set of __geoms__, and (3) a __coordinate system__. These are built in *layers*. 

A plot is built using the `ggplot()` function. This creates a default coordinate system where layers can be added on. The first argument is the dataset to use in the graph. For example, `ggplot(data = mpg)` tells `ggplot2` to set up an empty graph where the `mpg` dataset will be the data used for plotting. 

The layers we add are geometrical objects called __geoms__. We have a natural intuition for the type of geom a plot uses, e.g., bar charts use *bar* geoms and line charts use *line* geoms. Scatter plots, however, use *point* geoms. There are many more geoms available; the `ggplot2` [cheatsheet provides a nice overview](https://rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf). 

To display data values, variables in the dataset are mapped to *aesthetic*, or visual, properties of the geom, such as shape, size, and x and y locations. So each geom function will take an argument called `mapping` paired with a function call to `aes()` to specify the mapping from variable to aesthetic. `ggplot2` will look for the mapped variables inside the data argument; in this case, `mpg`. Let's see how these components come together in a scatter plot.    

### Scatter Plots 

A *scatter plot* displays the relation between two numerical variables. You saw an example of a scatter plot in an early section where we looked at the number of periods and number of characters in two classic novels. We will use a scatter plot here to visualize the relationship between a car's fuel efficiency (`hwy`) and the number of engines it has (`displ`).

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy))
```

Here, a point geom is used where the variables `displ` and `hwy` from `mpg` are mapped to the aesthetics `x` and `y`. Each point corresponds to one car model in the dataset. You can see that it slopes downward, in general. The more engines a car has, the less fuel efficient it is -- in general. 

Formally, we say that the plot shows an *association* between the variables, and that the association is *negative*: high values of one variable tend to be associated with low values of the other, and low values of one with high values of the other, in general. Later in the course we will study how to quantify association. For the moment, we will just think about it qualitatively.

Of course there is some variability. For instance, observe the group of car models that have a large numbers of engines, yet are still fuel efficient. We are suspect that these points are *outliers* because they lie outside the general range of the data. 

How can we explain these points? One way is to introduce a new variable `class` to visualize how the "type" of car impacts its fuel efficiency. The plot above can be amended to include a color aesthetic, where the type of car is mapped to a color. 

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```

This visualization makes one thing very clear: the outliers are sports cars! Even though sports cars have larger engines, they are more efficient than other cars with more engines because of their smaller body form, compared to SUVs.

__Other types of aesthetics.__ It is possible to include other types of aesthetics other than the color used in the above plot. For instance, the class can be mapped to `shape` or `alpha` aesthetics. 

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```

### Positional Adjustments

The careful reader will observe that there are 234 entries in the dataset. However, much less (only 109 to be exact) appears in the scatterplot. The issue is that the points are rounded so the points appear on a grid and many points overlap each other. This problem is known as __overplotting__. This makes it hard to see where the mass of the data is. 

The gridding can be avoided by setting the position adjustment to “jitter” in the geom.  `position = "jitter"` adds a small amount of random noise to each point. This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r, fig.align="center", dpi=80}
ggplot(data = mpg) +
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```

### Line Graphs

Line graphs are among the most common visualizations and are often used to study chronological trends and patterns. For instance, we can use a line graph to study `airmiles`, which contains data about passenger miles on commercial US airlines between 1937 and 1960. 

```{r, echo = FALSE}
df_airmiles <- data.frame(
  miles = as.matrix(airmiles), date = time(airmiles))
```

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(data = df_airmiles) + 
  geom_line(mapping = aes(x = date, y = miles))
ggplot(data = df_airmiles) + 
  geom_smooth(mapping = aes(x = date, y = miles))
```

The line geom creates the familiar line graph we typically think of while the smooth geom "smooths" the line to aid the eye in seeing overall patterns; the line geom, in contrast, is much more "ridgy". The smooth geom also adds confidence bands on the smoother.

The smooth geom can be useful to confirm the negative trend observed in the `mpg` data frame. 

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

Here we have layered *two* geoms in the same graph: a point geom and a smooth geom. Note how the outlier points have influenced the overall shape of the curve to bend upward, muddying the claim that there is a strong negative trend present in the data. Armed with our understanding about sports cars, we can adjust the visualization by setting aside points with `class == "2seater"`.         

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars) + 
    geom_point(mapping = aes(x = displ, y = hwy, color = class)) + 
    geom_smooth(mapping = aes(x = displ, y = hwy))
```

This plot shows a much more graceful trend downward. Before moving on, we point out some redundancy present in our plotting code. Namely, we have defined the same mapping for `x` and `y` in two different places. This could cause some unexpected surprises when writing code: imagine if we wanted to change the y-axis to `cty` instead of `hwy`, but we forgot to change both occurrences of `hwy`. This can be amended by moving the mapping to `ggplot()`.     

```{r, eval = FALSE}
no_sports_cars <- filter(mpg, class != "2seater")
ggplot(data = no_sports_cars, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth()
```

We can extend this idea further to specify different `data` for each layer. Here, the smooth geom displays only a subset of the data, the sports cars.  

```{r, eval = FALSE, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
    geom_point(mapping = aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

We can also write this more concisely by omitting some keywords:

```{r, fig.align="center", dpi=80, message = FALSE, warning = FALSE, results = FALSE}
ggplot(mpg, aes(x = displ, y = hwy)) + 
    geom_point(aes(color = class)) + 
    geom_smooth(data = filter(mpg, class != "2seater"))
```

In the rewritings we have taken here, the same effect is obtained. 

## Visualizing Categorical Distributions 

Data come in many forms that are not numerical. Data can be pieces of music, or places on a map. They can also be categories into which you can place individuals. Here are some examples of *categorical* variables.

* The individuals are pies sold, and the variable is the type of pie.
* The individuals are diamonds, and the variable is the quality of the cut.
* The individuals are car manufacturers, and the variable is the class of the car, e.g., "compact", "SUV",  and "pickup."
* The individuals are survey respondents, and the variable is the response they choose from among "Not at all satisfied," "Somewhat satisfied," and "Very satisfied."

### Prerequisites

This section will continue to make use of `ggplot2`, so we will need the tidyverse. Moreover, we will make use of datasets that are not available in the tidyverse, but are available in the package `faraway`. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(faraway)
```

### The `happy` and `diamonds` data frames

The table `happy` contains data on 39 students in a Univeristy of Chicago MBA class. 

```{r}
happy
```

Armed with what we have learned about `ggplot2`, we can begin answering questions about this dataset using table manipulation and visualization techniques. For instance, which "happiness" scores are the most frequent among the students? Moreover, can an association be determined between feelings of belongingness and higher scores of happiness? How about family income?  

Before we inspect this dataset any further, we will also consider another table called `diamonds`, which contains data on almost 54,000 diamonds.   

```{r}
diamonds
```

The *values* of the categorical variable *cut* are "fair", "good", "very good", "ideal", and "premium". We can look at how many diamonds are in each category. 

```{r, message = FALSE}
diamonds %>%
  group_by(cut) %>%
  summarise(count = n())
```

The table shows the number of diamonds of each cut. We call this a *distribution table*. A distribution shows all the values of a variable, along with the frequency of each one.

### Bar Chart

The bar chart is a familiar way of visualizing categorical distributions. It displays a bar for each category. The bars are equally spaced and equally wide. The length of each bar is proportional to the frequency of the corresponding category.

```{r, fig.align="center", dpi=80, warning = FALSE}
ggplot(data = diamonds, mapping = aes(x = cut)) + 
  geom_bar()
```

The y-axis displays *cut*, a variable from `diamonds`. However, the x-axis displays *count*, a variable not from `diamonds`. How is this possible? 

Line geoms and point geoms simply plot the raw values given from the dataset. Bar geoms, however, calculate *new* values to plot, like a *count*. The algorithm used to compute the new values is called a statistical transformation, or __stat__. It works as follows.

```{r, echo=FALSE, fig.align="center", fig.asp=1/2, fig.cap="Figure courtesy of *R for Data Science*, Grolemund and Wickham"}
knitr::include_graphics('images/visualization-stat-bar.png')
```

To summarize: `ggplot2` transforms the raw table to a new dataset of categories with its corresponding counts. From this new table, the bar plot is constructed by mapping `cut` to the x-axis and `count` to the y-axis. 

The default stat used is `stat_count()`, which counts the number of cases at each `x` position. If the counts are already present in the dataset and we would prefer to instead use these directly  for the heights of the bars, we can set `stat = "identity"`. For instance, consider this table about popular pies sold at a bakery. The "count" is already present in the `sold` variable. 

```{r, fig.align="center", dpi=80, warning = FALSE}
store_pies <- tribble(
  ~pie,             ~sold,
  "Pecan",            906,
  "Key Lime",         620,
  "Pumpkin",          202,
  "Apple",            408,
  "Mississippi mud",  551
)
ggplot(data = store_pies) +
  geom_bar(mapping = aes(x = pie, y = sold), stat = "identity")
```

Note how both `x` and `y` aesthetics must be provided when using the `identity` stat. 

### Towards numerical variables 

Let's turn to the `happy` data frame. We can consider the *categories* to be points on the 10-point scale, and the *individuals* the students in each interval. Let's determine this distribution table. 

```{r out.width = "50%", fig.align="default", message = FALSE}
happy_students <- group_by(happy, happy) %>% 
  summarise(count = n())
happy_students
```
We can now use this table, along with the graphing skills that we acquired above, to draw a bar chart that shows which scores are most frequent among the 39 students.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = reorder(happy, -count), y = count), stat = "identity") +
  xlab("Happy score")
```

There is something unsettling about this chart. Though it does answer the question of which "happy" scores appear most frequently among the students, it doesn't list the scores in chronological order. It is treating `happy` as a categorical variable.

But the scores are fixed chronological units that do have an order. Let's see what happens when we try to take that into account. In the `ggplot2` code written above, `reorder()` was used to sort the categories (scores) from highest to lowest. Let's run the code again without sorting by count.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy_students) + 
  geom_bar(aes(x = happy, y = count), stat = "identity") +
  xlab("Happy score")
```

Now the scores are in increasing order. We can attempt an answer to our second question: is there an association between feelings of belonginess and "happy" scores? Put another way, what relationship, if any, exists between `love` and `happy`? 

### More on positional adjustments

With point geoms we saw the usefulness of the "jitter" position adjustment to overcome the problem of overplotting. Bar geoms similarly benefit from positional adjustments. For instance, we can set the `color` or `fill` of a bar plot.

```{r eval = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

```{r echo = FALSE, out.width = "50%", fig.align="default", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, color = as.factor(happy)))
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(happy)))
```

To make this code work, note how the parameter passed to the `color` and `fill` aesthetic is converted to a factor, or categorical variable, via `as.factor()`. As discussed, the `happy` variable is *numerical*. However, `ggplot2` can only color or fill a bar chart based on a categorical variable.    

Something interesting happens when the fill aesthetic is mapped to another variable other than `happy`, e.g., `love`.

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)))
```

This visualization produces a "stacked" bar chart! Each bar is a composite of both `happy` and `love`. It also reveals something else that is interesting: feelings of belonginess are associated with higher marks on the "happy" scale. While we must maintain caution about making any causative statements at this point, this visualization demonstrates that bar charts can be a useful aid when exploring a dataset for possible relationships.

The stacking is performed by the position adjustment specified by the `position` argument. Observe how the bar chart changes with these other options: 

* `position = "fill"` makes each bar the same height. This way we can compare proportions across groups. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "fill")
```

* `position = "dodge"` places the stacked bars directly *beside* one another. This makes it easier to compare individual values. 

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love)), position = "dodge")
```

Bar charts are intended as visualizations of categorical variables. When the variable is numerical, the numerical relations between its values have to be taken into account when we create visualizations. That is the topic of the next section. Before ending the discussion here, we turn to one more important piece of `ggplot2` magic.  

### Coordinate Systems 

We noted earlier that one of the three motifs of any `ggplot2` plot is its coordinate system. In all of the `ggplot2` code we have seen so far, there has been no explicit mention as to the coordinate system to use. Why? If no coordinate system is specified, `ggplot2` will default to using the Cartesian (i.e., horizontal and vertical) coordinate system. In Cartesian coordinates, the `x` and `y` coordinates are used to define the location of every point in the dataset, as we have just seen. 

This is not the only coordinate system offered by `ggplot2`, and learning about other coordinate systems that are available can help boost the overall quality of a visualization.

* `coord_flip()` flips the `x` and `y` axes. For instance, this can be useful when the x-axis labels on a bar chart overlap each other.  

```{r dpi=80, fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip()
```


* `coord_polar()` uses polar coordinates. It is useful for plotting a Coxcomb chart. Note the connection between this and a bar chart.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_polar()
```

* `coord_cartesian(xlim, ylim)` can be passed arguments for "zooming in" the plot. For instance, we may want to limit the height of very tall bars (and, similarly, the effect of very small bars) in a bar chart by passing in a range of possible y-values to `ylim`.   

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(happy) +
  geom_bar(aes(x = happy, fill = as.factor(love))) + 
  coord_flip() +
  coord_cartesian(ylim=c(1,10))
```

This can also be a neat trick for eliminating the (awkward) gap between the bars and the x-axis :-)

## Visualizing Numerical Distributions 

Many of the variables that data scientists study are *quantitative* or *numerical*. Their values are numbers on which you can perform arithmetic. Examples that we have seen include the number of periods in chapters of a book, the amount of money made by movies, and the age of people in the United States.

The values of a categorical variable can be given numerical codes, but that doesn't make the variable quantitative. In the example in which we studied MBA student data broken down by marks on a "happiness" scale, the categorical variable `love` had the numerical codes 1 for "lonely," 2 for "secure relationship," and 3 for "feelings of belonging and caring". While 1, 2, and 3 are numbers, in this context it doesn't make sense to subtract 1 from 2, or take the average of 1, 2, and 3, or perform other arithmetic on the three values. `love` is a categorical variable even though the values have been given a numerical code.

For our main example, we will return to a dataset we studied when we were learning scatter and line plots. It is the table `mpg`, which consists of data on fuel efficiency of popular car models. Use `?mpg` for a description of the dataset. 

### Visualizing the Distribution of `hwy`

In this section we will draw graphs of the distribution of the numerical variable in the column `hwy`, which describes miles per gallon of car models on the highway. For simplicity, let's create a subset of the table that includes only the information we need. We'll show a snapshot of this table by sampling 10 random rows from it.  

```{r}
mpg_sub <- select(mpg, manufacturer, model, hwy)
slice_sample(mpg_sub, n = 10)
```

### A Histogram 

A *histogram* of a numerical dataset looks very much like a bar chart, though it has some important differences that we will examine in this section. First, let's just draw a histogram of the highway miles per gallon.

The geom histogram generates a histogram of the values in a column. Note how the `y` aesthetic is mapped to a computed variable `..density..` (we will see what is being computed in just a moment). The histogram below shows the distribution of `hwy`. 

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg_sub, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..))
```

### The Horizontal Axis 

The amounts have been grouped into contiguous intervals called bins. The histogram geom has an endpoint convention: bins include the data at their right endpoint, but not the data at their left endpoint. We will use the notation (a, b] for the bin that starts at a and ends at b but doesn't include a. Sometimes, adjustments have to be made in the first or last bin, to ensure that the smallest and largest values of the variable are included. 

We can see that there are about 30 bins (bars with no height are hard to distinguish), and that they all have the same width. We can also see that no car models had less than 10 highway miles per gallon. 

It is a little harder to see exactly where the ends of the bins are situated. For example, it is not easy to pinpoint exactly where the value 22 lies on the horizontal axis. So it is hard to judge exactly where one bar ends and the next begins.

The optional argument `breaks` can be used with the histogram geom to specify the endpoints of the bins. It must consist of a sequence of numbers that starts with the left end of the first bin and ends with the right end of the last bin, which is provided by the function `seq()`.  We will start by setting the numbers in bins to be 10, 11, 12, and so on, ending with 50.

```{r dpi=80,  fig.align="center", message = FALSE}
bins <- seq(10,50,1)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "gray", breaks = bins)
```

The tallest bar contains car models with `hwy` equal to 26. A small number of cars have `hwy ` greater than 30.  

### The Counts in the Bins 

The counts of values in the bins can be computed from a data frame using `cut()`, which takes a column of data and the bin boundaries. The result is a tabular form of a histogram. It lists the right endpoints of the bins (but see the note about the final value, below) and the counts of all values in the hwy column that are in the corresponding bin. That is, it counts all the hwy values that are greater than or equal to the value in bin, but less than the next value in bin.

```{r}
binned <- mpg_sub %>%
  mutate(bin = cut(hwy, breaks = bins)) %>%
  count(bin, .drop = FALSE) %>%
  print(n = Inf)
```

Notice the bin value 10 in the first row. That's not the right end-point of any bar – it's the left end point of the first bar. By the endpoint convention, the data there are not included. So the corresponding count is recorded as 0, and would have been recorded as 0 even if there had been cars with `hwy` less than 10. When either the histogram geom or `cut()` is called with a breaks argument, the graph only considers values that are in the specified bins. Once values have been binned, the resulting counts can be used by `ggplot2` to generate a histogram.  

### The Vertical Axis: Density Scale 

The horizontal axis of a histogram is straightforward to read, once we have taken care of details like the ends of the bins. The features of the vertical axis require a little more attention. We will go over them one by one.

Let's start by examining how to calculate the numbers on the vertical axis. If the calculation seems a little strange, have patience – the rest of the section will explain the reasoning.

__Calculation.__ The height of each bar is the percent of elements that fall into the corresponding bin, relative to the width of the bin.

```{r}
binned %>%
  mutate(percents = n / nrow(mpg_sub) * 100, 
         height = percents / 100) %>%
  print(n = Inf)
```

Go over the numbers on the vertical axis of the histogram above to check that the column `height` looks correct.

The calculations will become clear if we just examine the first row of the table.

Remember that there are 234 rows in the dataset. The (25, 26] bin contains 32 cars. That's 13.67% of all the cars: 

\[ Percent= \frac{32}{234} * 100 = 13.67 \]

The width of the (25, 26] bin is  $26 - 25 = 1$. So 

\[ Height = \frac{13.67}{100} = 0.1367 \]

The code for calculating the heights used the facts that there are 234 cars in all and that the width of each bin is 1.

This method of drawing histograms creates a vertical axis that is said to be *on the density scale*. The height of bar is __not__ the percent of entries in the bin; it is the percent of entries in the bin relative to the amount of space in the bin. That is why the height measures crowdedness or *density*.

Let's see why this matters.

### Unequal Bins

An advantage of the histogram over a bar chart is that a histogram can contain bins of unequal width. Below, the values in the `hwy` column are binned into three uneven categories.

```{r dpi=80,  fig.align="center", message = FALSE}
uneven_bins <- c(10, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey", 
                 breaks = uneven_bins, position = "identity")

```

Here are the counts in the three bins.

```{r}
mpg_sub %>%
  mutate(bin = cut(hwy, breaks = uneven_bins)) %>%
  count(bin, .drop = FALSE)
```

Although the ranges (10, 15] and (30, 45] have nearly identical counts, the bar over the former is twice as tall as the latter because it is only half as wide. The density of values in the (10, 15] is twice as much as the density in (30, 45].

Histograms help us visualize where on the number line the data are most concentrated, especially when the bins are uneven.

### The Problem with Simply Plotting Counts 

It is possible to display counts directly in a chart, by omitting the aesthetic mapping from `y` to `..density..`. The resulting chart has the same shape as a histogram when the bins all have equal widths, though the numbers on the vertical axis are different.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = bins, position = "identity")
```

While the count scale is perhaps more natural to interpret than the density scale, the chart becomes highly misleading when bins have different widths. Below, it appears (due to the count scale) that car models with high miles per gallon on the highway are more common than before, when in fact we have seen that they are relatively rare.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = uneven_bins, position = "identity")
```

Even though the geom used is a histogram, the figure above is __NOT A HISTOGRAM__. It misleadingly exaggerates the proportion of car models with `hwy` between 30 and 45 because the count of 10 to 15 is 17 and the count between 30 to 45 is 22. However, in the graph, the area of 10 to 15 is almost one-third of 30 to 45, which does not align with the true proportion. The height of each bar is simply plotted at the number of car models in the bin, without accounting for the difference in the widths of the bins.

The picture becomes even more absurd if the last two bins are combined.

```{r dpi=80,  fig.align="center", message = FALSE}
very_uneven_bins <- c(10, 15, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(color = "grey", breaks = very_uneven_bins, position = "identity")
```

In this count-based figure, the shape of the distribution of highway mileage per gallon is lost entirely.

### The Histogram: General Principles and Calculation 

The figure above shows that what the eye perceives as "big" is area, not just height. This observation becomes particularly important when the bins have different widths.
That is why a histogram has two defining properties:

1. The bins are drawn to scale and are contiguous (though some might be empty), because the values on the horizontal axis are numerical.

2. The __area__ of each bar is proportional to the number of entries in the bin.

Property 2 is the key to drawing a histogram, and is usually achieved as follows:

\[ \text{area of bar} = \text{percent of entries in bin} \]

The calculation of the heights just uses the fact that the bar is a rectangle:

\[ \text{area of bar} = \text{height of bar} × \text{width of bin} \]

and so

\[ \text{height of bar} = 
    \frac{\text{area of bar}}{\text{width of bin}} = 
    \frac{\text{percent of entries in bin}}{\text{width of bin}} \]

The units of height are "percent per unit on the horizontal axis."

When drawn using this method, the histogram is said to be drawn on the density scale. On this scale:

* The area of each bar is equal to the percent of data values that are in the corresponding bin.

* The total area of all the bars in the histogram is 100%. Speaking in terms of proportions, we say that the areas of all the bars in a histogram "sum to 1".


### Flat Tops and the Level of Detail 

Even though the density scale correctly represents percents using area, some detail is lost by grouping values into bins.

Take another look at the (10, 15] bin in the figure below. The flat top of the bar, at the density level 0.0145, hides the fact that the highway mileage is somewhat unevenly distributed across that bin.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), 
                 color = "grey",breaks = uneven_bins, position = "identity")
```

To see this, let us split the (10, 15] bin into 4 narrower bins, each of width 1.

```{r dpi=80,  fig.align="center", message = FALSE}
tiny_bins <- c(10, 11, 12, 13, 14, 15, 30, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey",
                 breaks = tiny_bins, position = "identity")
```

Some of the skinny bars are taller than 0.0145 and others are shorter; (10, 11] and  (12, 13] have heights of 0 because there is no data in these intervals. By putting a flat top at the level 0.0145 across the whole bin, we are deciding to ignore the finer detail and are using the flat level as a rough approximation. Often, though not always, this is sufficient for understanding the general shape of the distribution.

__The height as a rough approximation.__ This observation gives us a different way of thinking about the height. Look again at the (10, 15] bin in the earlier histograms. As we have seen, the bin is 5 hwy wide and contains 7.3% of the data. Therefore the height of the corresponding bar is at density level 0.0145.

Now think of the bin as consisting of 5 narrow bins that are each 1 wide. The bar's height of 0.0145 means that as a rough approximation, 1.45% of car models are in each of those 5 skinny bins of width 1 highway mile per gallon. 

Notice that because we have the entire dataset that is being used to draw the histograms, we can draw the histograms to as fine a level of detail as the data and our patience will allow. However, if you are looking at a histogram in a book or on a website, and you don't have access to the underlying dataset, then it becomes important to have a clear understanding of the "rough approximation" created by the flat tops.

### Histograms Q&A

Let's draw the histogram again, this time with four bins, and check our understanding of the concepts.

```{r dpi=80,  fig.align="center", message = FALSE}
some_new_bins <- c(10, 15, 23, 45)
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(aes(y = ..density..), color = "grey",
                 breaks = some_new_bins, position = "identity")
```

```{r}
mpg_sub %>%
  mutate(bin = cut(hwy, breaks = some_new_bins)) %>%
  count(bin, .drop = FALSE) 
```

Look again at the histogram, and compare the (15, 23] bin with the (23, 45] bin.

__Q__: Which has more car models in it?

__A__: The (23, 45] bin. It has 129 cars, compared with 88 cars in the (15, 23] bin.

__Q__: Then why is the (23, 45] bar shorter than the (15, 23] bar?

__A__: Because height represents density per unit of space in the bin, not the number of car models in the bin. The (23, 45] bin does have more car models than the (15, 23] bin, but it is also a whole lot wider. So it is less crowded. The density of car models in it is much lower.

### Differences Between Bar Charts and Histograms 

* Bar charts display one quantity per category. They are often used to display the distributions of categorical variables. Histograms display the distributions of quantitative variables.

* All the bars in a bar chart have the same width, and there is an equal amount of space between consecutive bars. The bars of a histogram can have different widths, and they are contiguous.

* The lengths (or heights, if the bars are drawn vertically) of the bars in a bar chart are proportional to the value for each category. The heights of bars in a histogram measure densities; the areas of bars in a histogram are proportional to the numbers of entries in the bins.


