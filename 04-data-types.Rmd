---
output:
  pdf_document: default
  html_document: default
---
# Data Types and Vectors

In this chapter we learn four fundamental data types of R and an important data structure "vector".
We also spend a bit of time studying the package `stringr`, which is part of `tidyverse`.


## Principal Data Types in R

We previously talked about mathematical expressions and data sets.
Our data sets take the form of tables, where the column representing attributes with labels and the rows represent the data objects.
What do you expect to see as the value for an attribute belonging to an individual?
More precisely, what kind of information comprises the thing you see in a cell of a table?
If you break down the information into pieces in the framework of R, upi get to one of the four types:
* a whole number, which we call the *integer* type,
* a real number, which we call the *double* type,
* a truth value representing true or false, which R calls the *logical* type and we commonly call the *Boolean* type, and
* a character sequence, which R calls the *character* type and we commonly call the *string* type.

### A quick overview of the data types

We often call the logical type as the *Boolean* type.
Some programming languages have multiple integer types and double types depending on how large (or how small) numbers they can represent.
The vacuum tubes we mentioned earlier as one of the principal ideas in the early modern computers had the role of regulating flow of electricity.
The architects of the machines used two conditions, the existence of current and the non-existence of current, for information coding.
We used the word *bit* to present the dichotomy, 1 for having the current and 0 for not having the current.
All the computer models that followed used the principle.
An integer type consists of some fixed number of (for example, 32) bits.
One of the bits for representing the sign (1 for negative numbers and 0 for non-negative numbers) and the rest are to represent the absolute value of the number with the power-of-2 denominations.
The power-of-2 denominations consist of the powers of 2 in increasing order starting from the 0-th power (which is equal to 0): $2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8, 2^4 = 16, \ldots$.
We call this the *binary representation* as opposed to the *decimal representation* as we write numbers in our daily life.
For example,
$$
0 \cdots 0 1 1 1 0 1
$$
in the representation is to represent by reading the bits from right to left,
$$
1 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2 + 1 \cdot 2^3 + 1 \cdot 2^4
$$
which is equal to $1 + 4 + 8 + 16 = 29$.
This means that there is a limit to how large a positive whole number or how small a negative whole number R can accurately represent.
If a number should go out of the range of accurately-presentable whole numbers, R switches to a oduble number using some approximation.

To represent a double number, computers split the number of bits it can use to three parts: the sign (1 bit), the *significand*, and the *exponent*.
How R uses the significand and exponents in representing a real number will be too technical. 
Where the value of base is 2 or 10, depending the standard the system uses.

$$
(\mathrm{sign}) ~(\mathrm{number~significand~represents}) \cdot (\mathrm{base})^{\mathrm{number~exponent~represents}}
$$
<!-- The significand refers to a number greater than or equal to 1 and strictly less than 2. By subtracting one from the significand you get a number greater than or equal to 0 and strictly less than 1. R uses the inverse powers of 2 to represent the significand (minus 1): $1/2, 1/2^2, 1/2^3, 1/2^4, \ldots$. For example, 0.75 is equal to $1/2 + 1/4$ and so its significand (minus 1) is $110\cdots 0$.
With $1$ that we have subtracted back in, $110\cdots 0$ represents $1.75$.
The exponent part is the integer representation in a smaller scale: with one bit for the sign and the remaining exponent bits for the absolute value of the exponent.
-->
The representation in the significant part uses the inverse powers of 2: 1/2, 1/4, 1/8, $\ldots$, down to a certain value $1/2^m$, where $m$ is the length of the significand part.
By combining these fractional quantities and the value of 1 we automatically add, we can obtain an approximation for a number between 1 and 2.
Like integer, the double type thus has a range of numbers it can record an approximation.

### Specifiying Whole Number Literals

If you type a sequence of numerals with intention of specifying a whole number, R shows it as a whole number to you, but it internally processes it as a double number.
If you want to ensure that the number remain a whole number, you attach the uppercase `L` after the numerals.

You cannot attach the letter `L` to a numerical sequence with a decimal point.


A *character* is a character sequence.
We use a matching pair of double quotations or a matching pair of single quotation marks (a matching pair of apostrophes) to mark the start and the end of the character sequence we specify its contents.
An advantage of using the double quotation marks is that single quotation marks can appear in the character sequence.

Here are some examples of these data types.

```{r}
TRUE
FALSE
3675
3657L
-34
1.07
"programming languages"
'United States of America'
```

Notice that the R substituted the single quotation marks we used for the last literal with double quotation marks.

### The Function `typeof()`

The function `typeof()` responds with the typoe of data.
Let us see what it says about the literals we defined in the above.

```{r}
typeof(TRUE)
typeof(FALSE)
typeof(3675)
typeof(3657L)
typeof(-34)
typeof(1.07)
typeof("programming languages")
typeof('United States of America')
```

The `typeof()` function is applicable to other staff.
Recall that `abs` is the function that returns the absolute value of a number.
If you ask R what type `abs` is, it says `builtin`.

```{r}
typeof(abs)
```

In the previous chapter, we saw some examples of using functions from the package `tidyverse`.
One function was `filter()`.
What is the type of `filter()`?

```{r}
library(tidyverse)
typeof(filter)
```

__Combining Doubles and Integers__

The double data type is an extension of the integer type.
When a mathematical expression contains a double and an integer, the result is always a double.
The third expression `4L + 1` adds an integer 4 and a double together and so is double.
In the fourth one, 1 is also an integer, and so the result is an integer.
We can confirm the types using `typeof()`.

```{r}
3.5 + 1.2
3L + 1.3
4L + 1
4L + 1L
typeof(4L + 1)
typeof(4L + 1L)
```


### Finding the Size Limit

How big numbers (or negative with big absolute value) can a double represent?
To specify a double number with a large absolute value, we can use the `e` expression.
If you type a literal that goes beyond the range, R gives you `Inf` or `-Inf` to mean that the number is out of range.
Let's start with `e1000`.

```{r, error=TRUE}
-1.0e1000
1.0e1000
```

So, using whether the result is `Inf` or not, we can explore around where between the boundary from the presentable numbers and the non-presentable numbers are:

```{r, error=TRUE}
1.0e500
1.0e400
1.0e300
1.0e310
1.0e305
1.0e306
1.0e307
1.5e308
1.6e308
1.7e308
1.8e308
1.790e308
```

So, around `1.79e308` is the limit.
The quantity is large enough so as to accommodate the computation we will do in the course.


How about integers? We can do the same explorations with `L` at the end of the number literals.
If you supply too big an integer that is presentable as a double, you get an error message saying that R must convert it to a double.
Around 2,147,000,000 (2 billions and 247 millions), the boundary exists.

## Strings and Their Operations

There is a variety of operations that are available in the base R (that is, the R without library incorporation) for manipulating strings.
A part of the `tidyverse` super-library is the `stringr` library.
We will discuss some `stringr` functions later.
Right now, let us introduce some of the standard functions of string manipulations in the base R.

### Conversions to and from Numbers

First of all, the characters are not compatible with numbers.
You cannot apply mathematical operations to strings even if their character contents are interpret-able as numbers.
In other words, `"4786"` is a character sequence with four characters, `"4"`, `"7"`, `"8"`, and `"6"`.
It is not the number "four thousand, seven hundred, and eight-six".
Knowing that the string can mean the number, we can generate an integer representing the number using the function `as.integer`.

```{r}
as.integer("4786")
```

The `as` functions are useful also when you want to interpret a string as a double and when you want to interpret a number as a string.
The functions `as.double` and `as.character` converts a string to a double number and a number to a string, respectively.

```{r}
as.double("3.14")
as.double("456")
as.character(3.14159265)
as.character(-465)
```

### Substring

If you know the contents of the string, you can count the characters in the sequence to obtain its length.
However, if you do not know or if the string is very long, you can rely on R to do the counting for you using `nchar`.

```{r}
nchar("310A Ungar Building, 1365 Memorial Drive, Coral Gables, Florida 33146")
```
A string is a sequence of characters.
Each character composing a string receives a unique position.
The positioning starts from the left end of the sequence.
The first position has value 1.
For example, the four characters of the string `"song"`, `"s"`, `"o"`, `"n"`, and `"g"` has positions 1, 2, 3, and 4, respectively.
You can specify a string and two positions and obtain a new string consisting of the characters between the two positions.
For example, the substring from position 2 to position 3 of the string "song" is "on".
The name of the function is `substring`.
The syntax is `substring(some_string, start, end)` where `some_string` from which we will build a substring, `start` is the staring position, and `end` is the ending position.

```{r}
substring("song", 2, 3)
```

You can omit the ending position if it is the last position of the string.
If the starting number is less than -1, R adjusts it to 1, and
if the ending number is greater than the length of the string, R adjusts it to the length of the string.
If the ending position is smaller than the starting position, the substring is the empty.

```{r}
substring("song", 2)
substring("song", -1, 6)
substring("song", 2, 0)
```




### Pasting

Often, we want to combine multiple into a single string.
We call the action *concatenation*.
There are two types of concatenation.
One type connects strings with no gap, the other connects strings with on white space inserted in between.
The two actions are `paste0` and `paste` in R.
Below, we think of concatenating three strings `"data"`, `"science"`, and `"101"` with the two methods individidually.


```{r}
s <- "data"
t <- "science"
u <- "101"
s
t
u
stu <- paste0(s, t, u)
s_t_u <- paste(s, t, u)
stu
s_t_u
```




## Boolean

As we stated before, Boolean is the data type for logical values, true and false.
`TRUE` is the value representing true and `FALSE` is the one representing false.
When you use a number where R is expecting to see a Boolean, it interprets 0 as `FALSE` and any non-zero as `TRUE`.
Here are the two values.

```{r}
TRUE
FALSE
```

### Comparisons 

While we can specify a Boolean value with a Boolean literal, we can use comparisons to generate Boolean values.
In the case of numbers, we can compare the values of two mathematical expressions.
There are six types of comparisons `==`, `!=`, `>` `>=`, `<`, and `<=`.
They represent "is equal to", "is not equal to", "is greater than", "is greater than or equal to", "is smaller", and "is smaller than or equal to".
For example, `1 + 4 > 7 - 4` asks if the value of `1 + 4` is strictly greater than the value of `1 - 7`.
The former is 5 and the latter is -6, and so the answer to the comparison is in the affirmative.
Therefore, the value of the comparison expression is `TRUE`.

With the numbers 5 and 4, the results of comparing the two values with the six comparison operators are as follows:

| Comparison               | Operator | True example | False Example |
|--------------------------|----------|--------------|---------------|
| Smaller than             | <        | 4 < 5        | 5 < 4         |
| Greater than             | >        | 5 > 4        | 4 > 4         |
| Smaller than or equal to | <=       | 4 <= 4       | 5 <= 4        |
| Greater than or equal to | >=       | 5 >= 5       | 4 >= 5        |
| Equal to                 | ==       | 4 == 4       | 5 == 4        |
| Not equal to             | !=       | 5 != 4       | 4 != 4        |


An expression can chain together multiple comparisons with the AND operator `&&`, and they all must hold in order for the whole expression to be `True`. For example, we can express that `1+1` is between `1` and `3` using the following expression.

```{r}
1 < (1 + 1) && (1 + 1) < 3
```

You may recall the functions `max` and `min` for obtaining the maximum and the minimum from a group of numbers, respectively.
One thing to remember is that the minimum is greater than or equal to the average, and the maxim um is greater than or equal to the average.
The equality holds when the two numbers in the group are all identical.
Let us set some numbers to variables `x` and `y` and see what the maximum and the minimum functions produce.

```{r}
x <- 12
y <- 5
min(x, y) <= (x + y)/2
max(x, y) >= (x + y)/2
```

How about the equality?
Assuming that we have executed the previous section of the code, we can reuse `x` and `y` in the following computation.

```{r}
x <- 17
y <- 17
min(x, y) == (x + y)/2
max(x, y) == (x + y)/2
```

__Boolean Operations__

There are three fundamental Boolean operations.
They are *negation*, *disjunction*, and *conjunction*.
Negation flips the value of a Boolean.
Disjunction tests if at least one of Boolean values appearing on a list is true and conjunction tests if all values appearing on a list are.
R uses symbols `!`, `||`, and `&&` for them.
Here are some examples of using the Boolean operations.

```{r}
a <- TRUE
b <- FALSE
c <- TRUE
!a
a || b || c
a && b && c
```

The roles these operations play are analogous to the roles $-$, $+$, and $*$ play in the numbers.

__Comparing Strings__

R can compare strings for equality and non-equality using `==` and `!=`.
R can also compare two to see if one is greater than the other and if one is smaller than the other.
To compare two strings, R compares their characters position-wise, starting from the beginning.
The position-wise continues until it reaches a position where either no comparison is possible because either at least one string has no characters remaining or the two strings showing non-identical pair of characters.
In the first case, if R has run out of characters on both sides, it asserts that the two strings are equal to each other, otherwise, the one that has just run out of characters is smaller than the other.
In the second case, R examines the *character code* of the two characters.
R (and any programming language) uses a table of characters where each character has a unique number.
The result of comparing two characters is that if the two characters are not equal to each other, then the character with at a lower position than the other is smaller than the other as character.


```{r}
a <- "Jason"
b <- "Bourne"
c <- "Matt"
d <- "Damon"
a < b
a > b && c > d
a > b || d < c
!(a < b)
```

The examples below show how R interprets numbers to Boolean values.

```{r}
3.0 == TRUE
-5 == FALSE
0 == TRUE
0 == FALSE
```

## Vectors

You might have been wondering about the meaning of the `[1]` that appears when you inquire about the value of an expression.
The square brackets `[]` in R means the position in a series of distinct elements.
The `[1]` indicates that the value that follows is the first element of the series that contains the value.
Wait! What we are saying here is that the value is not a standalone value "per se" but it appears as an element of a series.

Encompassing a value in a series is a distinctive feature of R.
In more technical terms, R uses *vectorization* to put objects in vectors.
Suppose we have assigned a value of 10 to an object `a`.

```{r}
a <- 10
```

Then `a` is a *vector* containing one element, whose value is 10.
If you type `a` as the expression, R returns

```{r}
a
```

The `[1] 10` appearing as the output states exactly that.

The way we access an element of a vector is to state the position of the element in the sequence comprising the vector inside square brackets and attach it after the name of the vector.
So, let us see what `a[1]` returns.
The expression means to refer to the first element of `a`, which we know to be 10.

```{r}
a[1]
```

Wait a second, it still says `[1] 10`.
Do you get `10` instead?
Because a vector is the most primitive information structure that R uses, there is no smaller structure.
This means that you can apply `[1]` as many times you want to `a`.

```{r}
a[1][1]
a[1][1][1]
a[1][1][1][1]
a[1][1][1][1][1]
```

Since the number inside the brackets specifies a position, you can try a number other than 1.
It is only that in the case of `a`, positions other than 1 do not exist.

```{r}
a[2]
a[0]
```

What are these?
`NA` is short-hard for "not available" and means that there is no such a thing.
`numeric(0)` means that it is a vector with no elements.
Once you get to length 0, `[1]` becomes `NA` but `[0]` produces `numeric(0)`.

```{r}
a[0][1]
a[0][0]
```

`numeric(N)` with `N` produces a series having length `N` where each element if 0.
So `numeric(0)` is a number sequence having 0.
Similar operations are possible for `character` and `logical'.
For `character`, the value is `""`, which is the string having length 0.
For `logical`, the value is `FALSE`.

```{r}
series_n <- numeric(6)
series_c <- character(8)
series_l <- logical(7)
series_n
series_c
series_l
```

We can then examine there contents and even change the values.
Below we change the values of `series_n` at positions 2 and 4 to 2 and 4, respectively.

```{r}
series_n[2] <- 2
series_n[4] <- 4
series_n
series_n[2]
series_n[4]
```

Let's play with these series a bit more.
In addition to specify a single position, you can give a range of positions, "from here to there".
The syntax for a range specification is `FROM:TO` where `FROM` is the starting position and `TO` is the ending position.
The code below changes the values for the 6 positions of `series_n` and then provides examples of some range indexing.

```{r}
series_n[1] = 3
series_n[2] = 5
series_n[3] = 7
series_n[4] = 11
series_n[5] = 13
series_n[6] = 17
series_n
series_n[1:5]
series_n[2:4]
series_n[2:2]
```

If the `END` value is smaller than the `START` value, the elements appear in the reverse order.

```{r}
series_n[4:1]
```


You can use the negative sign in the range and position specification.
The `-` sign means "all positions other than".
If the negative sign appears with the `FROM` or the `TO` index, then the other index must have the negative sign.
In the case of the negative ranging, the order between `FROM` and `TO` does not matter.

```{r}
series_n
series_n[-3]
series_n[-2:-4]
series_n[-4:-2]
```

Can you specify a series of positions to generate a subsequence:?
Yes, you can.
For such an operation, it is good to know how to create a sequence with element specification.
The creation of this kind uses the function `c`, which represents to "combine".
The syntax is quite simple.
Within the parentheses following the initial `c`, state the elements of the series with a comma in between.

```{r}
c(6, 2, 3)
c("university", "colleges", "and", "schools")
c(3.0, 4.0, 2.0, 2.2, -4.5, -25.7)
```

Using the `c` construction, you can obtain a subseries of a mother sequence with specific positions.
R retrieves the elements individually, and whether the numbers repeat or whether the numbers are in order do not matter.

```{r}
series_n[c(1,3,4)]
series_n[c(4,4,3,3,5,3,5,3)]
```

### The Combine Function

Let us look at the combine more closely.
We can define two series having the same lengths using the combine function.
In two series having the same lengths, we can execute component-wise addition, subtraction, multiplication, division, and remainder.

```{r}
a <- c(2, 3, 4, 5, 1, 6)
b <- c(9, 8, 7, 1, 2, 1)
a + b
a - b
a * b
a / b
a %% b
```

We can also apply an identical action to every element of a series.

```{r}
a + 100
a - 7
a * 3
b / 2
b %% 3
```

Not only can we apply mathematical operations but also we can apply comparison.
```{r}
a > b
a >= 3
```

Once you have a sequence of Boolean whose length is equal to the vector at hand, you can use that Boolean sequence (or vector) to select elements to generate subvectors.

```{r}
a[a > b]
a[a >= 3]
```

You can access some properties of the number.
`length`, `max`, and `min` provide the legnth of a vector, the maximum among the elements in a vector, and the minimum among the elements in it, respectively.
Since the elements are comparable with each other, the maximum and minimum are available for string vector as well.

```{r}
length(a)
max(a)
min(a)
ggg <- c("a", "b", "c", "aa", "bb", "cc")
max(ggg)
min(ggg)
```

In the case of numbers, the summation of all elements is possible.

```{r}
sum(a)
```

Another important feature of the function `c` is you can connect two vectors with `c`.
Here we recall the vectors `a` and `b` from earlier and then present the difference between the component-wise addition `a + b` and the sequence connection `c(a, b)`.

```{r}
a
b
a + b
c(a, b)
```

Since a single value is a vector, connecting a vector with a conspicuously single value are actually vector concatenation.
You can connect more than two elements.

```{r}
c(a, 10)
c(78, a)
c(79, a, 17)
```


### Functions on Vectors

R provides programmers with convenient and powerful functions for creating and manipulating vectors. 

The `mean` of a collection of numbers is its average value: the sum divided by the length. Each of the examples below performs a computation on the vector called `highs`.

```{r}
highs <- c(87.5, 87.5, 66.5, 90.0, 65.5, 71.0)
length(highs)
```

```{r}
sum(highs)
```

```{r}
mean(highs)
```

The `diff` function computes the difference between each adjacent pair of elements in an array. The first element of the `diff` is the second element minus the first. 

```{r}
diff(highs)
```

Following are some more commonly used functions that work over vectors.  Learning this vocabulary is an important part of learning the R language, so refer back to this list often as you work through examples and problems. 

However, you **do NOT need to memorize these**.  Use this as a reference.

Each of these functions takes some vector `x` as an argument and returns a single value.

| **Function**       | Description                                                          |
|--------------------|----------------------------------------------------------------------|
| `prod(x)`          | Multiply all elements together                                          |
| `sum(x)`           | Add all elements together                                               |
| `all(x)`           | Test whether all elements are true values (non-zero numbers are true)   |
| `any(x)`           | Test whether any elements are true values (non-zero numbers are true)   |
| `sum(x != 0)`      | Count the number of non-zero elements                                   |

Each of these functions takes some vector `x` as an argument and returns a vector of values.

| **Function**       | Description                                                          |
|--------------------|----------------------------------------------------------------------|
| `diff(x)`          | Difference between adjacent elements                                 |
| `round(x)`         | Round each number to the nearest integer (whole number)              |
| `cumprod(x)`       | A cumulative product: for each element, multiply all elements so far |
| `cumsum(x)`        | A cumulative sum: for each element, add all elements so far          |
| `exp(x)`           | Exponentiate each element                                            |
| `log(x)`           | Take the natural logarithm of each element                           |
| `sqrt(x)`          | Take the square root of each element                                 |
| `sort(x)`          | Sort the elements                                                    |


<!--
The `stringr` package from the tidyverse provides us a collection of useful functions for working with character vectors. A full cheat sheet can be found [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf), but listed here are some of the commonly used ones. Following are functions that take a character vector `x` as an argument and return a vector.  

| **Function**        | **Description**                                              |
|---------------------|--------------------------------------------------------------|
| `str_to_lower(x)`     | Lowercase each element                                       |
| `str_to_upper(x)`     | Uppercase each element                                       |
| `str_trim(x)`       | Remove spaces at the beginning and/or end of each element        |

The following function takes a character vector `x` with additional arguments, but also returns a vector. 

| **Function**        | **Description**                                              |
|---------------------|--------------------------------------------------------------|
|`str_sub(x, start, end)` | Extracts a substring from `x` given by `start` position and `end` position |
| `str_detect(x, "[:alpha:]")`   | Whether each element is only letters (no numbers or symbols) |
| `str_detect(x, "[:digit:]")`  | Whether each element is only numeric (no letters)             |

The following functions take both a character vector `x` and a *pattern string* to search for. Pattern strings can be more general like `"[:alpha:]"` or `"[:digit:]"` from the above list (these are also called [regular expressions](https://rstudio.com/wp-content/uploads/2016/09/RegExCheatsheet.pdf) or regexp for short, which we won't cover in detail :-). Each of these functions returns a vector.

| **Function**         | **Description**                                                                  |
|----------------------|----------------------------------------------------------------------------------|
| `str_count(x, pattern)`     | Count the number of times a pattern appears among the elements of an array |
| `str_which(x, pattern)`      | The indexes of vector `x` where the pattern is found                    |
| `str_replace_all(x, pattern)`| Replace all matched patterns in each string |
| `str_detect(x, ^pattern)` | Whether each element starts with the pattern |

The following function also takes a vector `x` of strings and a pattern string. However, unlike the above table, this function returns a *list*. We will cover lists in the next section. 

| **Function**         | **Description**                                                                  |
|----------------------|----------------------------------------------------------------------------------|
| `str_locate_all(x, pattern)` | The positions within each element that a pattern is found                |


The following function is a helpful diagnostic tool to view matched patterns.  

| **Function**         | **Description**                                                                  |
|----------------------|----------------------------------------------------------------------------------|
| `str_view_all(x, pattern)` | Visualizes all pattern matches in vector `x`                |
-->

## Lists 

Like vectors, lists also group values together. However, unlike vectors, lists can hold values that are of *different* types. For instance:

```{r}
mixed <- list("apple", 1.5, 2L, TRUE)
mixed
```

It can be helpful to examine the structure inside the list. We use `str` for this. 

```{r}
str(mixed)
```

Lists hold just about anything; they can even contain vectors... 

```{r}
mixed2 <- list(c("asparagus", "arrowroot", "tomato"), c("mango", "kumquat"), 3.14159)
str(mixed2)
```

...or more lists! 

```{r}
omg <- list(list(1,1), list(2,2,2), "hello world")
str(omg)
```

### Working with Lists 

Let's examine the `mixed2` list more closely. 

```{r}
mixed2
```

`[` extracts a sub-list. The result is always a list.

```{r}
str(mixed2[2])
```

We can also *subset* a list the same way we do with vectors. Remember that the result is still a list. 

```{r}
str(mixed2[1:2])
```

If we wish to extract the vector *inside* `mixed2[2]`, we must use `[[`. This extracts a single component from a list. We can use it to retrieve, for example, the vector of fruits: 

```{r}
mixed2[[2]]
```

What if we only wanted the mango? 

```{r}
mixed2[[2]][1]
```

Yum!

## String Manipulations with `stringr`

As we mentioned earlier, `tidyverse` is a collection of packages.
One of the packages `tidyverse` contains is `stringr`, which offers a variety of methods for manipulating strings.
Like numbers, a string is a vector of strings with just one string.
So, applying a function to a string is the same as applying a function to a string vector.
Depending on the roles, we can classify the functions in `stringr` roughly into the following categories:
* Finding and locating matches of a pattern in each string in a string vector
* Extracting subtrings and subvectors from a string vector matching a pattern
* Inquiring about the lengths and padding/trimming the strings
* Mutating the strings appearing in a string vector
* Changing the structure of a vector
* Sorting
* Character set conversion and viewing

### Regular expression

The pattern matching functions of `stringr` accept *regular expressions*.
A regular expression is a string that specifies a collection of strings in a possibly compact manner. Here are some examples of regular expressions and how one of the `stringr` functions `str_detect` uses it find patterns in string vector `c("May 17, 2019", "Certified mail", "FL 33333", "Oppa Locka", "to Mr. Haan", "arrived")`.
The function `str_detect` receives two arguments. The first is a string (or a string vector) and the second is the pattern. The function returns for each element in the vector, whether the pattern appears.
Let us first define a string vector with the five elements.

```{r}
s <- c("May 17, 2019", "Certified mail", "FL 33333", "Oppa Locka", "to Mr. Haan", "arrived")
s
```

Now you see a bracket with a number other than 1.
The `[5]` states that "to Mr. Haan" is the fifth element of the vector.

Let us load `tidyverse` to being.

```{r}
library(tidyverse)
```

The pattern strings appearing in the following have the following meaning

| pattern           | meaning                                                 |
|-------------------|---------------------------------------------------------|
|`"a"`              | any appearance of "a"                                   |
|`"a[iy]"`          | any "a" then one of "i" or "y"                          |
|`"a$"`             | "a" at the end of string                                |
|`"^a"`             | "a" at the start of string                              |
|`"^a.*d$"`         | "a" at the start, any string, and then a "d" at the end |
|`"ppa"`            | "ppa"                                                   |
|`"3{4}"`           | "3" repeated four times in sequence                     |
|`"[aeiou].[aeiou]"`| one from "aeiou", some character, and one from "aeiou"  |


```{r}
s
str_detect(s, "a")
str_detect(s, "a[iy]")
str_detect(s, "a$")
str_detect(s, "^a")
str_detect(s, "^a.*d$")
str_detect(s, "ppa")
str_detect(s, "3{4}")
str_detect(s, "[aeiou].[aeiou]")
```

So, the syntax is:
* use the square brackets to specify a list of characters
* use the curly brackets to specify the number of repetitions
* use the period to specify any character
* use the caret "^" and the dollar sign to specify the start and the end of string, respectively
* use * to specify any number of repetitions, including 0 repetitions.


In the square brackets you can specify a range using a dash and the caret to mean "not".
By putting a pair of numbers inside a pair of curly brackets, you can specify a permissible range of the number of repetitions.

The patterns below mean the following:

| pattern         | meaning                                        |
|-----------------|------------------------------------------------|
| `"[a-z]"`       | "a" through "z" at least one                   |
| `"[A-Z]{2,5}"`  | "A" through "Z" between 2 and 5 times          |
| `"[^a-zA-Z]"`   | a non-alphabet                                 |
| `"[0-9]"`       | a numeral                                      |


```{r}
s
str_detect(s, "[a-z]")
str_detect(s, "[A-Z]{2,5}")
str_detect(s, "[^a-zA-Z]")
str_detect(s, "[0-9]")
```

There are some other details about regular expressions and matching, but we will not present them here.
We will present any additional detail wherever we use it.


### `stringr` Functions

__Finding and locating matches__

There are functions in this category.
* `str_detect(STRING, PATTERN)`: As we have seen previously, the function returns a vector of Boolean representing whether the elements of `STRING` matching `PATTERN`.
* `str_which(STRING, PATTERN)`: The function works like `str_detect` but instead of Boolean vector, returns the indexes at which the pattern appears; in other words, at which indexes, the value of `str_detect(STRING, PATTERN)` is true.
* `str_count(STRING, PATTERN)`: The function returns for each element of `STRING`, at how many different positions the pattern aligns.
* `str_locate(STRING, PATTERN)`: The function finds for each element of `STRING`, the first (or the closest to the start of string) match of the pattern and provides the start and end character positions of the first match as a pair of integers (that is, a length-2 vector of integers). If there are no matches for an element of `STRING`, the function returns a pair of `NA`.

Let us recall `s`.
```{r}
s
```

Here is the result of finding "[0-9]" in the strings.

```{r}
str_which(s, "[0-9]")
```

Here is finding one of "aeiou" and any alphabet and counting the occurrences. Note that in "to Mr. Haan" there are two places that match the pattern `"[aeiou][A-Za-z]"`, that is "aa" and "an".
The pattern counting goes by repeating the action of finding the first match and then asserting the characters leading to the end of the match unusable for finding matches. With the feature, after finding the first, "aa", the prefix "to Mr. Haa" is no longer available, and so "an" does not qualify as a match.

```{r}
str_count(s, "[aeiou][A-Za-z]")
```

So, if we find three numerals in sequence with no gap, the elements 1 and 3 have exactly one match each, though there are multiple possibilities for aligning the pattern.

```{r}
str_count(s, "[0-9]{3}")
```

Here is the result of locating the pattern of any alphabet then a sequence of letters from "aeiou" at least one in sequence.

```{r}
str_locate(s, "[A-Za-z][aeiou]+")
```

What does the comma appearing in the six rows represent?
The comma represents that the  output of the function is actually is a data table and the series appearing after the comma is a row of the table whose row index is the number appearing before the comma.
In the case of our experiment at hand, `[4,] 3 4` means that row 4 of the table has 3 and 4 as elements.
To access the row at a specific position, we use the row index and then a comma, and to access the column at a specific position, we use a comma and then the column index.

```{r}
x <- str_locate(s, "[A-Za-z][aeiou]+")
x
x[,1]
x[,2]
x[1,]
x[2,]
```


There is an extension of `str_locate_all' which finds all the matches constructs a two-dimensional table for each element.
What function returns is thus a three-dimensional table.

```{r}
str_locate_all(s, "[A-Za-z][aeiou]+")
```


__Extracting subtrings and subvectors__

Here are the functions in this category.
* `str_sub(STRING, START, END)`: Creates a new vector consisting of the substrings of the elements of `STRING` with `START` and `END` as the staring and ending positions, respectively.
* `str_subset(STRING, pattern)`: Creates a new vector keeping only those elements in `s` matching the pattern.
* `str_extract(STRING, pattern)`: The same as `str_subset` concerning what to find, but the function returns a table not a one-dimensional vector.
See the examples below to examine the differences among `str_subset`, `str_extract`, and `str_match`.

```{r}
str_sub(s, 4, 7)
str_subset(s, "[a-zA-Z][^a-zA-Z]+[a-zA-Z]")
str_extract(s, "[a-zA-Z][^a-zA-Z]+[a-zA-Z]")
str_match(s, "[a-zA-Z][^a-zA-Z]+[a-zA-Z]")
```

Both `str_extract` and `str_match` have their version for "apply to all matches", like `str_locate_all`.
Their names are `str_extract_all` and `str_match_all`.


__Inquiring about the lengths and padding/trimming the strings__

The following functions belong to this category.
* `str_length(STRING)`: Returns the length of each element.
* `str_pad(STRING, WIDTH, side=OPTION, pad=X)`:Appends the string `X` to both or either side of each element of `STRING` as many times as necessary so as to inflate the length of element to at least `WIDTH`. The `OPTION` is one of `"left"`, `"right"`, and `"both"` to indicate where the padding should occur. They respectively represent "the left side only", "the right side only", and "both sides so as to center the original". If the original has length greater than or equal to `WIDTH` no padding occurs. In the case of "both", if the number of necessary padding is an odd number to make the length equal to `WIDTH`, the right side receives one more than the left side. The padding sTring `X` must be a single character. You may omit the specification part `pad=` in `pad=X`.
* `str_trunc(STRING, WIDTH, side=OPTION, ellipsis=E)`: This is in some sense at the opposite of `str_pad`. The function shrinks each string to length `WIDTH` with the single-character string `E` for replacement. The `side=` specification states where the replacement occurs and should be one of `"left"`, `"right"`, and `"center"`. You may omit the `ellipsis=` prefix.
* `str_trim(STRING, side=OPTION)`: Trims the white space at the end. The option value is one of `"left"`, `"right"`, and `"both"`, which correspond to "the left side only", "the right side only", and "both sides".

```{r}
str_length(s)
str_pad(s, 11, side="both", pad=".")
str_pad(s, 10, side="left", ".")
str_trunc(s, 3, side="right", ellipsis="_")
str_trunc(s, 5, side="center", "#")
str_trim("   abc    ", side="right")
str_trim("   abc    ", side="both")
```

__Mutating__

The first three functions execute substitutions to parts of each string.

* `str_sub() <- VALUE`: Here the `str_sub()` part follows the syntax of the method we earlier discussed - the substrings with specific range of indexes inside strings. After this action, each substring will become `VALUE`.

```{r}
s <- c("May 17, 2019", "Certified mail", "FL 33333", "Oppa Locka", "to Mr. Haan", "arrived")
```

Since the `str_sub() <- VALUE` modifies the original, let us copy `s` to `scopy` and then execute the action on the copy, not the original.
In that manner, we can preserve the original.
Note the use of 0 and 0 in the second instance, the position range of 0 through 0 corresponds to the part before the start of the string.

```{r}
scopy <- s
str_sub(scopy, 1, 3) <- "I am "
scopy
scopy <- s
str_sub(scopy, 0, 0) <- "I am "
scopy
s
```

* `str_replace(STRING, PATTERN, REPLACEMENT)`: Replaces the first occurrence of `PATTERN` with `REPLACEMENT`.
* `str_replace_all(STRING, PATTERN, REPLACEMENT)`: Replaces all occurrences of `PATTERN` with `REPLACEMENT`. Like `str_locate_all` the function finds a set of non-overlapping occurrences and then replaces all the occurrences it has identified.

Both functions return the vector resulting from their action.
The original remains intact.

```{r}
t <- s
str_replace(t, "a", "oo")
t <- s
str_replace_all(s, "a", "oo")
t <- s
str_replace_all(s,"[0-9][0-9]", "##")
```

There are three more string mutation functions.
* `str_to_lower(STRING)`: This converts each uppercase letter to its corresponding lowercase letter.
* `str_to_upper(STRING)`: This converts each lowercase letter to its corresponding uppercase letter.
* `str_to_title(STRING)`: This converts each string to a title-like format.

Each fo the three methods returns a new vector.

```{r}
t <- s
str_to_lower(s)
t <- s
str_to_upper(s)
t <- s
str_to_title(s)
```

__Changing the structure__

We only show three methods in this category.

* `str_dup(STRING, TIMES)`: Create from a vector `STRING`, a new vector where each element appears consecutively, without a gap, `TIMES` times.
* `str_split_fixed(STRING, PATTERN, TIMES)`: Create a new table with one more dimension from `STRING` where each element expands to a vector of `TIMES` elements by splitting at occurrences of `PATTERN`. If there are less than `TIMES` occurrences of the pattern, the function appends `""` to make the length exactly `TIMES`.
* `str_c(STRING)`: Collpoase the elements column-wise into a single dimensional vector.
* `str_c(STRING, collapse=X)`: Concatenate the elements column-wise with `X` in between and then concatenate the elements row-wise with `X` in between, thereby generating a single-element vector.

Below are examples.
Note that the action of `str_split_dfisxed` generates a two-dimensional vector from `s`.

```{r}
t <- s
str_dup(t, 3)
```

```{r}
t <- str_split_fixed(s, "[0-9 ]", 2)
t
```

```{r}
t <- str_split_fixed(s, "[0-9 ]", 2)
str_c(t)
t <- str_split_fixed(s, "[0-9 ]", 2)
str_c(t, collapse=":")

```

__Sorting__

There are two functions.
* `str_sort(STRING,decreasing=X,na_last=Y,numeric=Z)`: Sorts the elements as the string. The arguments after the first one are optional. `X`, `Y`, and `Z` are Boolean. With `decreasing=TRUE` the ordering is reverse. The `na_last=FALSE`, all `NA` move to the start. With `numeric=TRUE`, the function treats numerical sequences as numbers; otherwise, it treats them as character sequences.
* `str_order(...)`: The same arguments as `str_sort`, but instead of actually sorting, returns the sequence of indexes such that ordering the elements according to the index list produces the same result as `str_sort`.

```{r}
t <- str_split_fixed(s, "[0-9 ]", 2)
u <- str_c(t)
str_sort(u)
u <- str_c(t)
str_sort(u, decreasing=TRUE)
u <- str_c(t)
str_order(u, decreasing=TRUE)
```

```{r}
str_sort(t, decrease=TRUE)
```


__Character set conversion and viewing__

We cdo not talk about these functions here.

<!--
## Numbers 

Computers are designed to perform numerical calculations, but there are some important details about working with numbers that every programmer working with quantitative data should know. R (and most other programming languages) distinguishes between two different types of numbers:

* Integers are called `integer` values in the R language. They can only represent whole numbers (negative, zero, or positive) that don't have a fractional component.
* Real numbers are called `double` values (or *floating point values*) in the R language. They can represent whole or fractional numbers but have some limitations.

`double` values are evident from the way they are displayed: they always have a decimal point. 

```{r}
# Some double values
1.2
```

```{r}
3.0
```

```{r}
1.5 + 2.2
```

We can confirm these are doubles using the `typeof` function.

```{r}
typeof(3.0)
```

However, for numbers without a decimal point, i.e. integers, R will still treat them as `double`. 

```{r}
3  # here is a value that looks like an integer
typeof(3) # ..but is actually a double!
```

Hence, to create an integer, we must specify this explicitly by placing an `L` directly after the number. Here are some examples.

```{r}
# Some integer values
2L
```

```{r}
1L + 3L
```

```{r}
-123456789L
```

We can confirm these are integers using the `typeof` function.

```{r}
typeof(-123456789L)
```


When a `double` value is combined with an `integer` value using some arithmetic operator, then the result is always a `double` value. In most cases, two integers combine to form another integer, but any number (`integer` or `double`) divided by another will be a `double` value. Very large or very small `double` values are displayed using scientific notation.

```{r}
1.5 + 2L
```

```{r}
3L / 1L
```

```{r}
-12345678900000000000
```

We can use `typeof` to check these quantities. 

```{r}
typeof(1.5 + 2L)
typeof(3 / 1)
```

The `typeof` an expression is the type of its final value. So, the `typeof` function will never indicate that the type of an expression is a name, because names are always evaluated to their assigned values.

```{r}
x <- 3L
typeof(x) # The type of x is a integer, not a name
typeof(x + 2.5)
```

### More About Doubles

Double values are very flexible, but they do have limits. 

1. A `double` can represent extremely large and extremely small numbers. There are limits, but you will rarely encounter them.
2. A `double` only represents 15 or 16 significant digits for any number; the remaining precision is lost. This limited precision is enough for the vast majority of applications.
3. After combining `double` values with arithmetic, the last few digits may be incorrect. Small rounding errors are often confusing when first encountered.

The first limit can be observed in two ways. If the result of a computation is a very large number, then it is represented as infinite. If the result is a very small number, then it is represented as zero.

```{r}
2e306 * 10
2e306 * 100
2e-322 / 10
2e-322 / 100
```

The second limit can be observed by an expression that involves numbers with more than 15 significant digits. These extra digits are discarded before any arithmetic is carried out.

```{r}
0.6666666666666666 - 0.6666666666666666123456789
```

The third limit can be observed when taking the difference between two expressions that should be equivalent. For example, the expression `2 ** 0.5` computes the square root of 2, but squaring this value does not exactly recover 2.

```{r}
2 ** 0.5
(2 ** 0.5) * (2 ** 0.5)
(2 ** 0.5) * (2 ** 0.5) - 2
```

The final result above is `0.0000000000000004440892098500626`, a number that is very close to zero. The correct answer to this arithmetic expression is 0, but a small error in the final significant digit appears very different in scientific notation. This behavior appears in almost all programming languages because it is the result of the standard way that arithmetic is carried out on computers. 

Although `double` values are not always exact, they are certainly reliable and work the same way across all different kinds of computers and programming languages. 

## Strings

Much of the world's data is text, and a piece of text represented in a computer is called a *string*. A string can represent a word, a sentence, or even the contents of every book in a library. Since text can include numbers (like this: 5) or truth values (True), a string can also describe those things.

### Prerequisites

The `tidyverse` has some helpful functions from the `stringr` package for working with strings. Let's first load in the tidyverse.

```{r message=FALSE, warning=FALSE}
library(tidyverse)
```

### Working with Strings

In much the same way we can add together two numbers, we can add together two *strings*. The `str_c` function can accomplish this for us, which is an abbreviation for **str**ing **c**combine.   

```{r}
str_c("data", "science!")
```

`str_c` combined the two strings together without regard for their contents. It doesn't add a space because these are different words; that's up to the programmer (you) to specify.

```{r}
str_c("data", " ",  "science!")
```

Single and double quotes can both be used to create strings: `'hi'` and `"hi"` are identical expressions. Double quotes are often preferred because they allow you to include apostrophes inside of strings.

```{r}
"This won't work with a single-quoted string!"
```

Why not? Try it out.

We can also construct strings with `str_c` that have embedded values.

```{r}
str_c("That's ", 1 + 1, ' ', TRUE)
```

### String Functions

From an existing string, related strings can be constructed using string functions, which are functions that operate on strings. These methods are called by placing a dot after the string, then calling the function.

For example, `str_to_upper` generates an uppercased version of a string.

```{r}
str_to_upper("loud")
```

Perhaps the most important function is `str_replace` (and its variant `str_replace_all`), which replaces instances of a substring within the string. Both functions take three arguments, the string, text to be replaced, and its replacement. The following replaces *all* occurrences of `hi` with `ma` in the string `hitchhiker`.

```{r}
str_replace_all("hitchhiker", "hi", "ma")
```

String functions can also be invoked using variable names, as long as those names are bound to strings. So, for instance, the following two-step process generates the word "degrade" starting from "train" by first creating "ingrain" and then applying a second replacement.

```{r}
s <- "train"
t <- str_replace_all(s, "t", "ing")
u <- str_replace_all(t, "in", "de")
u
```

Note that the line `t <- str_replace_all(s, 't', 'ing')` doesn't change the string `s`, which is still "train". 

```{r}
s
```


## Comparisons 

Boolean values most often arise from comparison operators. R includes a variety of operators that compare values. For example, `3` is larger than `1 + 1`.

```{r}
3 > 1 + 1
```

The value `TRUE` indicates that the comparison is valid; R has confirmed this simple fact about the relationship between `3` and `1 + 1`. The full set of common comparison operators are listed below.

| Comparison         | Operator | True example | False Example |
|--------------------|----------|--------------|---------------|
| Less than          | <        | 2 < 3        | 2 < 2         |
| Greater than       | >        | 3>2          | 3>3           |
| Less than or equal | <=       | 2 <= 2       | 3 <= 2        |
| Greater or equal   | >=       | 3 >= 3       | 2 >= 3        |
| Equal              | ==       | 3 == 3       | 3 == 2        |
| Not equal          | !=       | 3 != 2       | 2 != 2        |


An expression can chain together multiple comparisons with the AND operator `&&`, and they all must hold in order for the whole expression to be `True`. For example, we can express that `1+1` is between `1` and `3` using the following expression.

```{r}
1 < (1 + 1) && (1 + 1) < 3
```

The average of two numbers is always between the smaller number and the larger number. We express this relationship for the numbers `x` and `y` below. You can try different values of `x` and `y` to confirm this relationship.

```{r}
x <- 12
y <- 5
min(x, y) <= (x + y)/2 && (x + y)/2 <= max(x, y)
```

Strings can also be compared, and their order is alphabetical. A shorter string is less than a longer string that begins with the shorter string.

```{r}
"Dog" > "Catastrophe" && "Catastrophe" > "Cat"
```



-->

