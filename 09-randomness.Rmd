# Randomness 

In the previous chapters we developed skills needed to make insightful descriptions of data. Data scientists also have to be able to understand randomness. For example, they have to be able to assign individuals to treatment and control groups at random, and then try to say whether any observed differences in the outcomes of the two groups are simply due to the random assignment or genuinely due to the treatment.

In this chapter, we begin our analysis of randomness. To start off, we will use R to make choices at random. R contains many functions that involve random selection. One of these functions is called `sample()`. It picks one item at random from an array, and it is equally likely to pick any of the items. The function call is `sample(vector_name, size)`, where `vector_name` is the name of the vector from which to make the choice and `size` is the number of items to choose. 

Thus the following code evaluates to treatment with chance 50%, and control with chance 50%.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
```

```{r}
two_groups <- c("treatment", "control")
sample(two_groups, size = 1)
```

The big difference between the code above and all the other code we have run thus far is that the code above doesn't always return the same value. It can return either `treatment` or `control`, and we don't know ahead of time which one it will pick. We can repeat the process by adjusting the `size` argument. Moreover, we will set `replace` to `TRUE` as we want to allow repetition in our draws, e.g., it should be permissible to draw from the `treatment` group more than once. 

```{r}
two_groups <- c("treatment", "control")
sample(two_groups, size = 10, replace = TRUE)
```

A fundamental question about random events is whether or not they occur. For example:

* Did an individual get assigned to the treatment group, or not?
* Is a gambler going to win money, or not?
* Has a poll made an accurate prediction, or not?

Once the event has occurred, you can answer "yes" or "no" to all these questions. In programming, it is conventional to do this by labeling statements as True or False. For example, if an individual did get assigned to the treatment group, then the statement, "The individual was assigned to the treatment group" would be `TRUE`. If not, it would be `FALSE`.

__Booleans and Comparison__

In R, Boolean values, named for the logician [George Boole](https://en.wikipedia.org/wiki/George_Boole), represent truth and take only two possible values: True and False. Whether problems involve randomness or not, Boolean values most often arise from comparison operators. Python includes a variety of operators that compare values. For example, `3` is larger than `1 + 1`.

```{r}
3 > 1 + 1
```

The value `TRUE` indicates that the comparison is valid; R has confirmed this simple fact about the relationship between `3` and `1 + 1`. The full set of common comparison operators are listed below.

```{r, echo=FALSE}
table <- tribble(~Comparison, ~Operator, ~True.Example, ~False.Example, 
                 "Less than", "<", "2 < 3", "2 < 2",
                 "Greater than", ">", "3 > 2", "3 > 3",
                 "Less than or equal", "<=", "2 <= 2", "3 <= 2",
                 "Greater or equal", ">=", "3 >= 3", "2 >= 3",
                 "Equal", "==", "3 == 3", "3 == 2",
                 "Not equal", "!=", "3 != 2", "2 != 2")
knitr::kable(table, col.names = gsub("[.]", " ", names(table)))
```

Notice the two equal signs `==` in the comparison to determine equality. This is necessary because Python already uses `=` to mean assignment to a name, as we have seen. It can't use the same symbol for a different purpose. Thus if you want to check whether 5 is equal to the 10/2, then you have to be careful: `5 = 10/2` returns an error message because R assumes you are trying to assign the value of the expression 10/2 to a name that is the numeral 5. Instead, you must use `5 == 10/2`, which evaluates to `TRUE`.

```{r, error=TRUE}
5 = 10/2
```

```{r}
5 == 10/2
```

__Comparing Strings__

Strings can also be compared, and their order is alphabetical. 

```{r}
print("Dog" > "Cat")
print("Alabama" > "Cat")
```

__Comparing an Array and a Value__

Recall that we can perform arithmetic operations on many numbers in a vector at once. For example, `c(0, 5, 2)*2` is equivalent to `c(0, 10, 4)`. In similar fashion, if we compare a vector and one value, each element of the vector is compared to that value, and the comparison evaluates to a vector of Booleans.

```{r}
tosses <- c("Tails", "Heads", "Tails", "Heads", "Heads")
tosses == "Heads"
```

While Booleans are logical data types and are therefore different from numerical data types, they are internally represented as `0` (for `FALSE`) and '1' (for `TRUE`). The `sum` function can be used to evaluate the number of non-zero (that is, `TRUE`) elements of the array.

```{r}
sum(tosses == "Heads")
```

## Conditional Statements

In many situations, actions and results depends on a specific set of conditions being satisfied. For example, individuals in randomized controlled trials receive the treatment if they have been assigned to the treatment group. A gambler makes money if she wins her bet.

### Prerequisites

As usual, we will make use of the tidyverse. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### The `if` statement

In this section we will learn how to describe such situations using code. A *conditional statement* is a multi-line statement that allows Python to choose among different alternatives based on the truth value of an expression. While conditional statements can appear anywhere, they appear most often within the body of a function in order to express alternative behavior depending on argument values.

A conditional statement always begins with an `if` header, which is a single line followed by an indented body. The body is only executed if the expression directly following `if` (called the *if expression*) evaluates to a true value. If the *if expression* evaluates to a false value, then the body of the `if` is skipped.

Let us start defining a function that returns the sign of a number.

```{r}
sign <- function(x) {
  if (x > 0) {
    return("Positive")
  }
}
sign(3)
```

This function returns the correct sign if the input is a positive number. But if the input is not a positive number, then the *if expression* evaluates to a false value, and so the `return` statement is skipped and the function call has no value.

```{r}
print(sign(-3))
```

So let us refine our function to return `Negative` if the input is a negative number. We can do this by adding an `else if` clause.

```{r}
sign <- function(x) {
  if (x > 0) {
    return("Positive")
  } else if (x < 0) {
    return("Negative")
  }
}
```

Now `sign` returns the correct answer when the input is -3:

```{r}
sign(-3)
```

What if the input is 0? To deal with this case, we can add another `else if` clause:

```{r}
sign <- function(x) {
  if (x > 0) {
    return("Positive")
  } else if (x < 0) {
    return("Negative")
  } else if (x == 0) {
    return("Neither positive nor negative")
  }
}
```

```{r}
sign(0)
```

Equivalently, we can replace the final `else if` clause by an `else` clause, whose body will be executed only if all the previous comparisons are false; that is, if the input value is equal to 0.

```{r}
sign <- function(x) {
  if (x > 0) {
    return("Positive")
  } else if (x < 0) {
    return("Negative")
  } else {
    return("Neither positive nor negative")
  }
}
```

```{r}
sign(0)
```

### The General Form

A conditional statement can also have multiple clauses with multiple bodies, and only one of those bodies can ever be executed. The general format of a multi-clause conditional statement appears below.

```
if (<if expression>) {
    <if body>
} else if (<elif expression 0>) {
    <elif body 0>
} else if (<elif expression 1>) {
    <elif body 1>
...
} else {
    <else body>
}
```

There is always exactly one `if` clause, but there can be any number of `else if` clauses. R will evaluate the `if` and `else if` expressions in the headers in order until one is found that is a true value, then execute the corresponding body. The `else` clause is optional. When an `else` header is provided, its *else body* is executed only if none of the header expressions of the previous clauses are true. The `else` clause must always come at the end (or not at all).

### Example: Betting on a Die

Suppose I bet on a roll of a fair die. The rules of the game:

* If the die shows 1 spot or 2 spots, I lose a dollar.
* If the die shows 3 spots or 4 spots, I neither lose money nor gain money.
* If the die shows 5 spots or 6 spots, I gain a dollar.

We will now use conditional statements to define a function `one_bet` that takes the number of spots on the roll and returns my net gain.

```{r}
one_bet <- function(x) {
  if (x <= 2) {
    return(-1)
  } else if (x <= 4) {
    return(0)
  } else if (x <= 6) {
    return(1)
  }
}
```

Let's check that the function does the right thing for each different number of spots.

```{r}
c(one_bet(1), one_bet(2), one_bet(3), one_bet (4), one_bet(5), one_bet(6))
```

As a review of how conditional statements work, let's see what `one_bet` does when the input is 3.

* First it evaluates the `if` expression, which is `3 <= 2` which is `False`. So `one_bet` doesn't execute the `if` body.
* Then it evaluates the first `else if` expression, which is `3 <= 4`, which is `True`. So `one_bet` executes the first `else if` body and returns 0.
* Once the body has been executed, the process is complete. The next `else if` expression is not evaluated.

If for some reason we use an input greater than 6, then the `if` expression evaluates to False as do both of the `else if` expressions. So one_bet does not execute the if body nor the two `else if` bodies, and there is no value when you make the call below.

```{r}
print(one_bet(17))
```

To play the game based on one roll of a die, you can use `sample()` to generate the number of spots and then use that as the argument to `one_bet()`. Run the cell a few times to see how the output changes.

```{r}
one_bet(sample(1:6, size = 1))
```

At this point it is natural to want to collect the results of all the bets so that we can analyze them. In the next section we develop a way to do this without running the cell over and over again.

## Iteration

It is often the case in programming – especially when dealing with randomness – that we want to repeat a process multiple times. For example, recall the game of betting on one roll of a die with the following rules:

* If the die shows 1 or 2 spots, my net gain is -1 dollar.
* If the die shows 3 or 4 spots, my net gain is 0 dollars.
* If the die shows 5 or 6 spots, my net gain is 1 dollar.

### Prerequisites

As usual, we will make use of the tidyverse. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### Betting on a Die

The function `bet_on_one_roll` takes no argument. Each time it is called, it simulates one roll of a fair die and returns the net gain in dollars.

```{r}
bet_on_one_roll <- function(x) {
  # Returns my net gain on one bet
  x <- sample(1:6, size = 1) # roll a die once and record the number of spots
  if (x <= 2) {
    return(-1)
  } else if (x <= 4) {
    return(0)
  } else if (x <= 6) {
    return(1)
  }
}
```

Playing this game once is easy:

```{r}
bet_on_one_roll()
```

To get a sense of how variable the results are, we have to play the game over and over again. We could run the cell repeatedly, but that's tedious, and if we wanted to do it a thousand times or a million times, forget it.

A more automated solution is to use a `for` statement to loop over the contents of a sequence. This is called *iteration*. A `for` statement begins with the word `for`, followed by a name we want to give each item in the sequence, followed by the word `in`, and ending with an expression that evaluates to a sequence. The indented body of the `for` statement is executed once *for each item in that sequence*.

```{r}
for (animal in c("cat", "dog", "rabbit")) {
  print(animal)
}
```

Here we use a `for` statement in a more realistic way: we print the results of betting five times on the die as described earlier. This is called *simulating* the results of five bets. We use the word *simulating* to remind ourselves that we are not physically rolling dice and exchanging money but using R to mimic the process.

To repeat a process `n` times, it is common to use the sequence `1:n` in the for statement. It is also common to use a very short name for each item. In our code we will use the name `i` to remind ourselves that it refers to an item.

```{r}
for (i in 1:5) {
  print(bet_on_one_roll())
}
```

In this case, we simply perform exactly the same (random) action several times, so the code in the body of our `for` statement does not actually refer to `i`.

While the `for` statement above does simulate the results of five bets, the results are simply printed and are not in a form that we can use for computation. A vector of results would be more useful. Thus a typical use of a `for` statement is to create a vector of results. 

### Example: Betting on 5 rolls 

Our experiment will simulate five bets on a die and collect the results in an vector that we will call `outcomes`. To be efficient, we will use the knowledge of the total number of simulations to pre-define the length of `outcomes`; this will help R speed up the computation. 

```{r}
num_rolls <- 5
outcomes <- vector("integer", num_rolls)  # create a vector with length num_rolls
for (i in 1:num_rolls) {
  outcomes[i] <- bet_on_one_roll()
}
```

```{r}
outcomes
```

This will do the job. The body of this `for` statement contains two actions: (1) run the betting function `bet_on_one_roll()`, and (2) store the result into `i`th slot of the `outcomes` vector. Both actions are executed for each item in the sequence `1:num_rolls`.

You may have noticed how cycling through the `outcomes` vector this way, individually assigning each element the result of one bet, can be cumbersome. If so, you would be in good company. The philosophy of R prefers to operate on vectors in whole, rather than in pieces as in the code we saw just above. In this way, we can eliminate the need for many common `for` statements. To demonstrate this, we introduce the idea of *maps* and *functionals*. 

### Maps and Functionals

Your midterm asks you to write code to capitalize the elements in a character vector. 

```{r}
some_characters <- c("b", "a", "N", "a", "N", "A", "!")
```

How can we do this with a computer? We know that the `toupper()` function can be used to capitalize a character (actually, it can do all of the work for us but let's not spoil the fun). We can try solving the problem using this function... 

```{r}
capitalized <- vector("character", length(some_characters))
capitalized[1] <- toupper(some_characters[1])
capitalized[2] <- toupper(some_characters[2])
capitalized[3] <- toupper(some_characters[3])
capitalized[4] <- toupper(some_characters[4])
capitalized[5] <- toupper(some_characters[5])
capitalized[6] <- toupper(some_characters[6])
capitalized[7] <- toupper(some_characters[7])
capitalized
```

Full marks. But what if the vector given was bigger? There wouldn't be any time left to work on the other problems! One way out of this jam is to observe the repetition in the code we have just written. We just learned that `for` statements are useful for performing the same action multiple times. In a ray of brilliance, the following revised code is produced.

```{r}
my_upper_function <- function(x) {
  capitalized <- vector("character", length(x))
  for (i in 1:length(x)) {
    capitalized[i] <- toupper(x[i])
  }
  return(capitalized)
}
my_upper_function(some_characters)
``` 

Much better! Moving on, you realize the next question asks you to convert the characters in the vector to *lowercase*. Another dilemma -- the function we wrote only works for capitalization! We need another for converting to lowercase. In a haste, you come up the following.  

```{r}
my_lower_function <- function(x) {
  lowered <- vector("character", length(x))
  for (i in 1:length(x)) {
    lowered[i] <- tolower(x[i])
  }
  return(lowered)
}
my_lower_function(some_characters)
``` 

Does this do the job? Yes. Full marks? Not a chance! We did not learn our lesson from last time: there is repetition in the code again! Besides name changes, a brand new function was written to make only one change: adjust the `toupper()` function call to `tolower()`. Moreover, there is ample room for introducing mistakes. If you were writing this on a computer and copy-and-pasting your capitalization code, it is all too easy to forget changing `toupper()` to `tolower()`, especially if we needed to call these functions more than once.       

The better approach here is to leverage the power of R and make use of *functionals*. Instead of writing two separate functions that perform common list challenges, use one function and pass it an additional *functional* argument. That is, 

```{r}
my_map_function <- function(x, func) {
  transformed <- vector("character", length(x))
  for (i in 1:length(x)) {
    transformed[i] <- func(x[i])
  }
  return(transformed)
}
```

We can call this new function by passing in the same vector `some_characters` and a functional argument `func` that will be either `tolower()` or `toupper()`. 

```{r}
my_map_function(some_characters, toupper)
my_map_function(some_characters, tolower)
```

By passing in different functional arguments, we are effectively transforming this *generalized* function into the lower and uppercase versions in our first draft. The grader is sure to be content with this solution (as well as the R gurus :-). 

The idea of passing a function to another function is an extremely powerful idea. However, the careful reader would beg to differ: how can this be used to *eliminate* writing `for` statements?  

To this end, we will make use of the [purrr](https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf) package available in tidyverse, which provides many functions that can be used to replace common `for` statements. The goal of using `purrr` functions is to break up common list manipulation challenges into smaller pieces by solving the problem first for a single element in the vector. From this, we can build up solutions for more complex problems. 

The main construct we will be using from `purrr` is the *map*. The `my_map_function()` we just wrote is one such example of a map: it applies a function (in this case, `toupper()` or `tolower()`) to each element of a vector or list. `purrr` offers many flavors of map, depending on what the output vector should look like: 

* `map_lgl()` outputs a logical vector.
* `map_int()` outputs an integer vector.
* `map_dbl()` outputs a double vector.
* `map_chr()` outputs a character vector.

We could easily have replaced our `my_map_function()` with a `purrr` version. 

```{r}
map_chr(some_characters, toupper)
map_chr(some_characters, tolower)
```

Here are some more examples of using map. Note how we can define a function and pass it in on the spot. We call these *anonymous functions*. The following is an identity function: it simply outputs what it takes in.  

```{r}
map_int(1:5, function(x) x)
```

This one is more useful. It computes the square of each element, i.e., $x^2$. 

```{r}
map_dbl(1:5, function(x) x ** 2)
```

> __Why use map_dbl() instead of map_int()?__ By default, R treats numbers as doubles. While `1:5` is a vector of integers, each element is subject to the expression `x ** 2`, where `x` is an integer and `2` is a double. To make this operation compatible, R will "promote" `x` to a double, making the output of this expression a double as well.  

This one will always return a vector of 5's. Can you see why? 

```{r}
map_dbl(1:5, function(x) 5)
```

While map eliminates the need to write `for` statements in common situations, keep in mind that R internally must still perform a `for` loop. Therefore, the chief benefit of using constructs like map is not for its speed, but clarity: it is much easier to read and write.

We now have all the pieces we need to take on the die roll simulation. 

### Example: Betting on 5 Rolls (revisited)

Let's recall the code we wrote earlier to perform the simulation.

```{r}
num_rolls <- 5
outcomes <- vector("integer", num_rolls)  # create a vector with length num_rolls
for (i in 1:num_rolls) {
  outcomes[i] <- bet_on_one_roll()
}
```

Using what we have learned about map, we can rewrite this simulation to just two lines. 

```{r}
num_rolls <- 5
outcomes <- map_dbl(1:num_rolls, bet_on_one_roll)
```

```{r}
outcomes
```

Note how the input vector `1:num_rolls` serves as a placeholder. Meaning, the values in this vector do not matter as they will be overwritten with the results from the bet; only the length of the vector is important. 

We can use `sum()` to count the number of times money changed hands.

```{r}
sum(outcomes)
```

### Example: Betting on 300 Rolls

Iteration using maps is a powerful technique. For example, we can see the variation in the results of 300 bets by running exactly the same code for 300 bets instead of five.

```{r}
num_rolls <- 300
outcomes <- map_dbl(1:num_rolls, bet_on_one_roll)
```

The vector `outcomes` contains the results of all 300 bets.

```{r}
length(outcomes)
```

To see how often the three different possible results appeared, we can create a tibble from `outcomes` and then use `ggplot2`.

```{r dpi=80,  fig.align="center", message = FALSE}
outcome_df <- tibble(outcomes)
ggplot(outcome_df, aes(x = outcomes)) + 
  geom_bar() + 
  coord_flip()
```

Not surprisingly, each of the three outcomes -1, 0, and 1 appeared about about 100 of the 300 times, give or take. We will examine the "give or take" amounts more closely in later chapters.

## Simulation

TBA

## The Monty Hall Problem

This [problem](https://en.wikipedia.org/wiki/Monty_Hall_problem) has flummoxed many people over the years, [mathematicians included](https://web.archive.org/web/20140413131827/http://www.decisionsciences.org/DecisionLine/Vol30/30_1/vazs30_1.pdf). Let's see if we can work it out by simulation.

The setting is derived from a television game show called "Let's Make a Deal". Monty Hall hosted this show in the 1960's, and it has since led to a number of spin-offs. An exciting part of the show was that while the contestants had the chance to win great prizes, they might instead end up with "zonks" that were less desirable. This is the basis for what is now known as the *Monty Hall problem*.

The setting is a game show in which the contestant is faced with three closed doors. Behind one of the doors is a fancy car, and behind each of the other two there is a goat. The contestant doesn't know where the car is, and has to attempt to find it under the following rules.

* The contestant makes an initial choice, but that door isn't opened.

* At least one of the other two doors must have a goat behind it. Monty opens one of these doors to reveal a goat, displayed in all its glory in [Wikipedia](https://en.wikipedia.org/wiki/Monty_Hall_problem):

```{r, echo=FALSE, fig.align="center", fig.asp=1/2}
knitr::include_graphics('images/monty_hall_goat.png')
```

* There are two doors left, one of which was the contestant's original choice. One of the doors has the car behind it, and the other one has a goat. The contestant now gets to choose which of the two doors to open.

The contestant has a decision to make. Which door should she choose to open, if she wants the car? Should she stick with her initial choice, or switch to the other door? That is the Monty Hall problem.

### Prerequisites

As usual, we will make use of the tidyverse. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### The Solution

In any problem involving chances, the assumptions about randomness are important. It's reasonable to assume that there is a 1/3 chance that the contestant's initial choice is the door that has the car behind it.

The solution to the problem is quite straightforward under this assumption, though the straightforward solution doesn't convince everyone. Here it is anyway.

* The chance that the car is behind the originally chosen door is 1/3.
* The car is behind either the originally chosen door or the door that remains. It can't be anywhere else.
* Therefore, the chance that the car is behind the door that remains is 2/3.
* Therefore, the contestant should switch.

That's it. End of story.

Not convinced? Then let's simulate the game and see how the results turn out.

### Simulation

The simulation will be more complex that those we have done so far. Let's break it down.

#### Step 1: What to Simulate {-#my-step1}

For each play we will simulate what's behind all three doors:

* the one the contestant first picks
* the one that Monty opens
* the remaining door

So we will be keeping track of three quantitites, not just one.

#### Step 2: Simulating One Play {-#my-step2}

The bulk of our work consists of simulating one play of the game. This involves several pieces.

__The Goats__ 

We start by setting up a vector `goats` that contains unimaginative names for the two goats.

```{r}
goats <- c("goat1", "goat2")
```

To help Monty conduct the game, we are going to have to identify which goat is selected and which one is revealed behind the open door. The function `other_goat` takes one goat and returns the other.

```{r}
other_goat <- function(x) {
  if (x == "goat1") {
    return("goat2")
  } else if (x == "goat2") {
    return("goat1")
  }
} 
```

Let's confirm that the function works.

```{r}
other_goat("goat1")
other_goat("goat2")
print(other_goat("goose"))
```

The string `"goose"` is not the name of one of the goats, so when `"goose"` is the input then the function does nothing and returns NULL.

__The Options__

The vector `hidden_behind_doors` contains the set of things that could be behind the doors.

```{r}
hidden_behind_doors <- c("goat1", "goat2", "car")
```

We are now ready to simulate one play. To do this, we will define a function `monty_hall_game` that takes no arguments. When the function is called, it plays Monty's game once and returns a list consisting of:

* the contestant's guess
* what Monty reveals when he opens a door
* what remains behind the other door

The game starts with the contestant choosing one door at random. In doing so, the contestant makes a random choice from among the car, the first goat, and the second goat.

If the contestant happens to pick one of the goats, then the other goat is revealed and the car is behind the remaining door.

If the contestant happens to pick the car, then Monty reveals one of the goats and the other goat is behind the remaining door.

```{r}
monty_hall_game <- function() {
  # Returns (contestant's guess, what Monty reveals, what remains behind the other door)
  pick <- sample(hidden_behind_doors, size = 1) 
  if (pick == "goat1") {
    return(c(pick, "goat2", "car"))
  } 
  
  if (pick == "goat2") {
    return(c(pick, "goat1", "car"))
  } 
  
  if (pick == "car") { 
    revealed <- sample(goats, size = 1)
    return(c(pick, revealed, other_goat(revealed)))
  }
}
```

Let's play! Run the function several times and see how the results change.

```{r}
monty_hall_game()
```

#### Step 3: Number of Repetitions {-#my-step3}

To gauge the frequency with which the different results occur, we have to play the game many times and collect the results. Let's run 10,000 repetitions.

#### Step 4: Coding the Simulation {-#my-step4}

It's time to run the whole simulation.

We will play the game 10,000 times and collect the results in a table. Each row of the table will contain the result of one play.

One way to grow a table by adding a new row is to use the `add_row()` function. If `df` is a data frame, or more conveniently, a `tibble`, and `new_row` is a vector (say, of size 2) containing the entries in a new row, then 
`add_row(df, column_a = new_row[1], column_b = new_row[2])` adds the new row to the bottom of `my_table`.

Note that `add_row()` does not create a new table. It changes `df` to have one more row than it did before, which must then be stored back in `df` if we wish to preserve those changes.  

First let's create a table `games` that has three empty columns. We can do this by just specifying a list of the column labels, as follows.

```{r}
games <- tibble(
  guess = character(),
  revealed = character(),
  remaining = character()
)
```

Notice that we have chosen the order of the columns to be the same as the order in which `monty_hall_game()` returns the result of one game.

Now we can add 10,000 rows to trials. Each row will represent the result of one play of Monty's game.

```{r}
for (i in 1:10000) {
  one_game <- monty_hall_game()
  games <- add_row(games, 
                   guess = one_game[1], 
                   revealed = one_game[2], 
                   remaining = one_game[3])
}
```

The simulation is done. Notice how short the code is. The majority of the work was done in simulating the outcome of one game.

### Visualization

To see whether the contestant should stick with her original choice or switch, let's see how frequently the car is behind each of her two options.

```{r}
original_choice <- games %>% 
  group_by(guess) %>%
  count() %>%
  mutate(which_door = "original")
original_choice
```

```{r}
remaining_doors <- games %>% 
  group_by(remaining) %>%
  count() %>%
  mutate(which_door = "remaining")
remaining_doors
```

As our earlier solution said, the car is behind the remaining door two-thirds of the time, to a pretty good approximation. The contestant is twice as likely to get the car if she switches than if she sticks with her original choice. 

To see this graphically, we can "stick" these two tables together and draw a stacked bar chart.

```{r}
original_choice <- original_choice %>% rename(item = guess)
remaining_doors <- remaining_doors %>% rename(item = remaining)
stuck_together <- bind_rows(original_choice, remaining_doors)
stuck_together
```

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(stuck_together, aes(x = item, y = n, fill = which_door)) + 
  geom_bar(position="dodge", stat = "identity") + 
  coord_flip()
```

Notice how the three reddish bars are almost equal – the original choice is equally likely to be any of the three available items. But the cyan bar corresponding to `Car` is twice as long as the red.

The simulation confirms that the contestant is twice as likely to win if she switches!

## Finding Probabilities 

Over the centuries, there has been considerable philosophical debate about what probabilities are. Some people think that probabilities are relative frequencies; others think they are long run relative frequencies; still others think that probabilities are a subjective measure of their own personal degree of uncertainty.

In this course, most probabilities will be relative frequencies, though many will have subjective interpretations. Regardless, the ways in which probabilities are calculated and combined are consistent across the different interpretations.

By convention, probabilities are numbers between 0 and 1, or, equivalently, 0% and 100%. Impossible events have probability 0. Events that are certain have probability 1.

Math is the main tool for finding probabilities exactly, though computers are useful for this purpose too. Simulation can provide excellent approximations, with high probability. In this section, we will informally develop a few simple rules that govern the calculation of probabilities. In subsequent sections we will return to simulations to approximate probabilities of complex events.

We will use the standard notation $P(event)$ to denote the probability that "event" happens, and we will use the words "chance" and "probability" interchangeably.

### Prerequisites

As usual, we will make use of the tidyverse. 

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
```

### When an Event Doesn't Happen 

If the chance that event happens is 40%, then the chance that it doesn't happen is 60%. This natural calculation can be described in general as follows:

\[ P(\text{an event doesn't happen}) = 1 - P(\text{the event happens})\]

### When All Outcomes are Equally Likely

If you are rolling an ordinary die, a natural assumption is that all six faces are equally likely. Then probabilities of how one roll comes out can be easily calculated as a ratio. For example, the chance that the die shows an even number is

\[ \frac{\text{number of even faces}}{\text{number of all faces}} = \frac{\#\{2,4,6\}}{\#\{1,2,3,4,5,6\} } = \frac{3}{6}\]

Similarly, 

\[ P(\text{die shows a multiple of 3}) = \frac{\#\{3, 6\}}{\#\{1,2,3,4,5,6\} } = \frac{2}{6}\]

In general,

\[ P(\text{an event happens}) = \frac{\#\{\text{outcomes that make the event happen}\}}{\#\{\text{all outcomes}\} }\]

provided all the outcomes are equally likely.

Not all random phenomena are as simple as one roll of a die. The two main rules of probability, developed below, allow mathematicians to find probabilities even in complex situations.

### When Two Events Must Both Happen 

Suppose you have a box that contains three tickets: one red, one blue, and one green. Suppose you draw two tickets at random without replacement; that is, you shuffle the three tickets, draw one, shuffle the remaining two, and draw another from those two. What is the chance you get the green ticket first, followed by the red one?

There are six possible pairs of colors: RB, BR, RG, GR, BG, GB (we've abbreviated the names of each color to just its first letter). All of these are equally likely by the sampling scheme, and only one of them (GR) makes the event happen. So

\[ P(\text{green first, then red}) = \frac{\#\{\text{GR}\}}{\#\{\text{RB, BR, RG, GR, BG, GB}\} } = \frac{1}{6}\]

But there is another way of arriving at the answer, by thinking about the event in two stages. First, the green ticket has to be drawn. That has chance $1/3$, which means that the green ticket is drawn first in about $1/3$ of all repetitions of the experiment. But that doesn't complete the event. *Among the 1/3 of repetitions when green is drawn first*, the red ticket has to be drawn next. That happens in about $1/2$ of those repetitions, and so:

\[ P(\text{green first, then red}) = \frac{1}{2} \text{ of } \frac{1}{3} = \frac{1}{6}\]

This calculation is usually written "in chronological order," as follows.

\[ P(\text{green first, then red}) = \frac{1}{2} \text{ × } \frac{1}{3} = \frac{1}{6}\]

The factor of $1/2$ is called "the conditional chance that the red ticket appears second, given that the green ticket appeared first."

In general, we have the __multiplication rule__:

\[P(\text{two events both happen}) \]
\[= P(\text{one event happens}) × P(\text{the other event happens, given that the first one happened}) \]

Thus, when there are two conditions – one event must happen, as well as another – the chance is a *fraction of a fraction*, which is smaller than either of the two component fractions. The more conditions that have to be satisfied, the less likely they are to all be satisfied.

### When an Event Can Happen in Two Different Ways 

Suppose instead we want the chance that one of the two tickets is green and the other red. This event doesn't specify the order in which the colors must appear. So they can appear in either order.

A good way to tackle problems like this is to partition the event so that it can happen in exactly one of several different ways. The natural partition of "one green and one red" is: GR, RG.

Each of GR and RG has chance $1/6$ by the calculation above. So you can calculate the chance of "one green and one red" by adding them up.

\[P(\text{one green and one red}) = P(\text{GR}) + P(\text{RG}) = \frac{1}{6} + \frac{1}{6} = \frac{2}{6} \]

In general, we have the __addition rule__:

\[P(\text{an event happens}) = P(\text{first way it can happen}) + P(\text{second way it can happen})\]

provided the event happens in exactly one of the two ways.

Thus, when an event can happen in one of two different ways, the chance that it happens is a sum of chances, and hence bigger than the chance of either of the individual ways.

The multiplication rule has a natural extension to more than two events, as we will see below. So also the addition rule has a natural extension to events that can happen in one of several different ways.

We end the section with examples that use combinations of all these rules.

### At Least One Success

Data scientists often work with random samples from populations. A question that sometimes arises is about the likelihood that a particular individual in the population is selected to be in the sample. To work out the chance, that individual is called a "success," and the problem is to find the chance that the sample contains a success.

To see how such chances might be calculated, we start with a simpler setting: tossing a coin two times.

If you toss a coin twice, there are four equally likely outcomes: HH, HT, TH, and TT. We have abbreviated "Heads" to H and "Tails" to T. The chance of getting at least one head in two tosses is therefore 3/4.

Another way of coming up with this answer is to work out what happens if you *don't* get at least one head: both the tosses have to land tails. So

\[P(\text{at least one head in two tosses}) = 1 - P(\text{both tails}) = 1 - \frac{1}{4} = \frac{3}{4}  \]

Notice also that

\[P(\text{both tails}) = \frac{1}{4} = \frac{1}{2} * \frac{1}{2} = (\frac{1}{2})^2  \]

by the multiplication rule.

These two observations allow us to find the chance of at least one head in any given number of tosses. For example,

\[P(\text{at least one head in 17 tosses}) = 1 - P(\text{all 17 are tails}) = 1 - (\frac{1}{2})^{17} \]

And now we are in a position to find the chance that the face with six spots comes up at least once in rolls of a die.

For example,

\[P(\text{a single roll is not 6}) = P(1) + P(2) + P(3) + P(4) + P(5) = \frac{5}{6} \]

Therefore,

\[P(\text{at least one 6 in two rolls}) = 1 - P(\text{both rolls are not 6}) = 1 - (\frac{5}{6})^2 \]

and

\[P(\text{at least one 6 in 17 rolls}) = 1 - (\frac{5}{6})^{17} \]

The table below shows these probabilities as the number of rolls increases from 1 to 50.

```{r}
rolls <- 1:51
results <- tibble(rolls = rolls,
                  prob_of_at_least_one_six = 1 - (5/6) ** rolls)
results
```

The chance that a 6 appears at least once rises rapidly as the number of rolls increases.

```{r dpi=80,  fig.align="center", message = FALSE}
ggplot(results) + 
  geom_point(aes(x = rolls, y = prob_of_at_least_one_six))
```

In 50 rolls, you are almost certain to get at least one 6.

```{r}
filter(results, rolls == 50) %>% as.data.frame()
```

If you have ever played games that rely heavily on "RNG" (*r*andom *n*umber *g*enerator), chances are you intuitively exploited this finding: just keep "rolling" until you find that rare item! 

Calculations like these can be used to find the chance that a particular individual is selected in a random sample. The exact calculation will depend on the sampling scheme. But what we have observed above can usually be generalized: increasing the size of the random sample increases the chance that an individual is selected.

